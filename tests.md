# Подготовка к собеседованию на Python

## 1. Объясните утверждение "В Python всё является объектом"
Что такое объект? В объектно-ориентированных языках программирования объект — это сущность, которая содержит данные и методы для работы с этими данными.  
В Python всё — числа, списки, строки, функции и классы — является объектами.

```python
>>> a = 10.5
>>> a.is_integer()  # У типа float есть метод is_integer(), потому что a — это объект класса float
False
>>> type(a)
<class 'float'>
>>> def func():
...    pass
>>> type(func)
<class 'function'>
>>> # Как и функции, классы также являются объектами класса 'type'
```

Пример:
```python
>>> var = 'Tom'  # Создается объект 'Tom' в памяти, и имя 'var' связывается с ним
>>> var = 'Harry'  # Создается другой объект, но имя 'var' теперь связано с 'Harry', а 'Tom' остается в памяти
```

## 2. Что такое изменяемые (mutable) и неизменяемые (immutable) объекты/типы данных?
Мутация означает "изменение". Говоря, что объект изменяемый или неизменяемый, мы подразумеваем, может ли его значение изменяться после создания.  
В Python каждый объект при создании получает тип и идентификатор. Объект является изменяемым, если его значение может меняться при сохранении того же идентификатора.

### Изменяемые объекты в Python
— Объекты, которые можно изменить после создания: списки, байтовые массивы, множества и словари.
```python
>>> list_var = [17, 10]
>>> list_var
[17, 10]
>>> id(list_var)
2289772854208
>>> list_var += [17]
>>> list_var
[17, 10, 17]
>>> id(list_var)  # Идентификатор объекта не изменился
2289772854208
```

### Неизменяемые объекты в Python
— Числовые типы, строки, байты, неизменяемые множества (frozenset) и кортежи.
```python
>>> # Пример с кортежами
>>> tuple_var = (17,)
>>> tuple_var
(17,)
>>> id(tuple_var)
1753146091504
>>> tuple_var += (10,)
>>> tuple_var
(17,10)
>>> id(tuple_var)  # Идентификатор изменился при изменении объекта
1753153466880
```

### Изменяемые объекты и аргументы функций
```python
def sample_func(sample_arg):
    sample_arg.append(10)
    # Не нужно возвращать объект, так как он использует тот же блок памяти

sample_list = [7, 8, 9]
sample_func(sample_list)
print(sample_list)  # [7, 8, 9, 10]
```

## 3. В чем разница между списками (list) и кортежами (tuple) в Python?

| Параметр | Список | Кортеж |
|----------|--------|--------|
| Синтаксис | Квадратные скобки или ключевое слово `list` | Круглые скобки или ключевое слово `tuple` |
| Изменяемость | Изменяемый | Неизменяемый |
| Присваивание элементов | Возможно | Невозможно |
| Повторное использование | Копируется | Не копируется |
| Производительность | Медленнее | Быстрее |
| Память | Больше (дополнительная память) | Фиксированный размер (по размеру элементов) |

Примечание: Кортежи можно определять без скобок: `a = 2, 3, 4`.

### Выделение памяти для кортежей и списков
Кортежи не выделяют дополнительную память при создании, так как они неизменяемы.
```python
>>> tuple_var = tuple()
>>> tuple_var.__sizeof__()  # 24 байта для пустого кортежа
24
>>> tuple_var = (1, 2)  # +8 байт для каждого целочисленного элемента
>>> tuple_var.__sizeof__()
40
```

Списки выделяют дополнительную память, чтобы операция `append` была O(1).
```python
>>> list_var = list()
>>> list_var.__sizeof__()  # 40 байт для пустого списка
40
>>> list_var.append(1)
>>> list_var.__sizeof__()  # Выделяется дополнительная память для будущих добавлений
72
>>> list_var
[1]
>>> list_var.append(2)
>>> list_var.__sizeof__()  # Размер не изменился, так как в списке есть место
72
>>> list_var
[1, 2]
```

### Повторное использование
Кортежи буквально присваивают тот же объект новой переменной, а списки копируют все элементы.
```python
>>> # Списки vs Кортежи | Повторное использование vs Копирование
>>> old_list = [1, 2]
>>> old_list.append(3)
>>> old_list
[1, 2, 3]
>>> id(old_list)
2594206915456
>>> old_list.__sizeof__()
88

>>> # Копирование списка
>>> new_list = list(old_list)
>>> new_list
[1, 2, 3]
>>> id(new_list)  # Новый идентификатор — создан новый список
2594207110976
>>> new_list.__sizeof__()  # Размер отличается от old_list
64

>>> # Копирование кортежа
>>> old_tuple = (1, 2)
>>> id(old_tuple)
2594206778048
>>> old_tuple.__sizeof__()
40
>>> new_tuple = tuple(old_tuple)
>>> id(new_tuple)  # Тот же идентификатор, что и у old_tuple
2594206778048
>>> new_tuple.__sizeof__()  # Тот же размер, так как ссылается на old_tuple
40
```

### Производительность
Кортежи и списки работают почти одинаково при индексации, но кортежи быстрее при создании.

## 4. Как управляется память в Python?
В отличие от других языков, Python хранит ссылки на объекты после их создания. Например, целочисленный объект `17` может иметь два имени (переменные в Python называются именами) — `a` и `b`. Менеджер памяти Python отслеживает количество ссылок на каждый объект (для `17` это будет 2). Когда счетчик ссылок достигает нуля, объект удаляется из памяти.  
Счетчик ссылок:
- Увеличивается, если объект присваивается новому имени или помещается в контейнер (например, кортеж или словарь).
- Уменьшается, когда ссылка на объект выходит из области видимости или имя присваивается другому объекту.  
Сборщик мусора Python автоматически удаляет объекты, и программисту не нужно заботиться о выделении/освобождении памяти, как в C.
```python
>>> import sys
>>> sys.getrefcount(17)
11
>>> a = 17
>>> b = 17
>>> a is b
True
>>> sys.getrefcount(17)
13  # Увеличилось на 2
```

## 5. Объясните обработку исключений в Python.
Обработка исключений позволяет управлять ошибками в программе без прерывания выполнения.
```python
try:
    # Код, который может вызвать ошибку
except TypeError:
    # Действия при возникновении ошибки (например, TypeError)
else:
    # Выполняется, если исключения не было (опционально)
finally:
    # Выполняется всегда после try и except (опционально)
```
Примеры исключений: `TypeError`, `ValueError`, `ImportError`, `KeyError`, `IndexError`, `NameError`, `PermissionError`, `EOFError`, `ZeroDivisionError`, `StopIteration`.

## 6. Объясните некоторые изменения в Python 3.8
### Позиционные аргументы
```python
def sum(a, b, /, c=10):
    return a + b + c
sum(10, 12, c=12)
```
### F-строки с операциями
```python
a, b = 10, 12
f"Сумма a и b: {a + b}"
f"Значение c: {(c := a + b)}"
```

## 7. Объясните шаблоны проектирования в Python.
(Ссылка на видео: https://www.youtube.com/watch?v=o1FZ_Bd4DSM)

## 8. Как загрузить большой файл данных в Python?
Лучший способ — загружать данные частями. В Pandas можно указать размер чанка:
```python
for chunk in pd.read_csv('file.csv', chunksize=1000):
    process(chunk)
    
pd.read_csv('file.csv', sep='\t', iterator=True, chunksize=1000)
```
Другой способ — использовать контекстный менеджер:
```python
with open("log.txt") as infile:
    for line in infile:
        process(line)
```

## 9. Объясните генераторы и их применение.
Функция или метод, использующий оператор `yield`, называется генераторной функцией. При вызове она возвращает итератор, который можно использовать для выполнения тела функции.  
Генераторы полезны для вычисления больших наборов результатов, когда не все результаты нужны сразу или когда не хочется выделять память для всех результатов одновременно.
```python
# Генератор для поиска, эффективен для возврата результатов с функциональностью типа "Загрузить еще 10 элементов"
def search_result(keyword):
    while keyword in dataset:
        yield matched_data

search_object = search_result('keyword')
# type(search_object)  --> <class 'generator'>

search_object.__next__()
```
Примечание: Генератор можно итерировать только один раз. При повторной итерации он не вернет значений. Генераторы не хранят все значения в памяти, а генерируют их на лету.
```python
mygenerator = (x*x for x in range(3))
```

## 10. Можно ли определить порядок исключений в блоке `except`?
Да, исключения можно определить в кортеже. Они будут обрабатываться слева направо в зависимости от возникшего исключения.
```python
try:
    pass
except (TypeError, IndexError, RuntimeError) as error:
    pass
```

## 11. Объясните замыкания (closures) в Python.
Замыкание — это функциональность Python, при которой некоторые данные сохраняются в памяти для отложенного выполнения. Декораторы активно используют замыкания.  
Чтобы создать замыкание в Python:
1. Должна быть вложенная функция (функция внутри внешней функции).
2. Вложенная функция должна ссылаться на значение, определенное во внешней функции.
3. Внешняя функция должна возвращать (не вызывать) вложенную функцию.
```python
def enclosing_function(defined_value):
    def nested_function():
        return defined_value + some_operation
    return nested_function

closure_function = enclosing_function(20)
closure_function()  # Возвращает 20 + some_operation
```
Объекты — это данные с прикрепленными методами, замыкания — это функции с прикрепленными данными.

## 12. Как сделать цепочку декораторов функций?
```python
def make_bold(fn):
    def wrapped():
        return "<b>" + fn() + "</b>"
    return wrapped

def make_italic(fn):
    def wrapped():
        return "<i>" + fn() + "</i>"
    return wrapped

@make_bold
@make_italic
def index():
    return "hello world"

print(index())  # Возвращает "<b><i>hello world</i></b>"
```

## 13. Три способа получить каждый третий элемент списка
### Использование шага в срезе
```python
>>> example_list = [0, 1, 2, 3, 4, 5, 6]
>>> example_list[::3]  # Возвращает [0, 3, 6]
```
### Использование спискового включения
```python
>>> [x for x in example_list if example_list.index(x) % 3 == 0]
>>> [0, 3, 6]
```
### Использование цикла while
```python
i = 0
while i < len(example_list):
    print(example_list[i])
    i += 3
```

## 14. Что такое MRO в Python? Как он работает?
MRO (Method Resolution Order) — это порядок, в котором Python ищет метод в иерархии классов. Особенно важен при множественном наследовании, когда один метод может быть найден в нескольких родительских классах.
```python
class A:
    def process(self):
        print('A')
        
class B(A):
    pass
    
class C(A):
    def process(self):
        print('C')

class D(B, C):
    pass
    
obj = D()
obj.process()  # D -> B -> C -> A -> object
```
Примечание: Класс не может быть вызван перед своим суперклассом в MRO. Суперкласс должен вызываться после производного класса.

## 15. Что такое monkey patching? Как его использовать в Python?
Monkey patching — это практика динамического изменения или расширения кода во время выполнения, обычно для изменения поведения существующих классов, модулей или функций.  

Monkey patching полезен в нескольких сценариях:
1. Тестирование: Позволяет заменять части кода mock-объектами или функциями.
2. Горячие исправления: Когда нельзя сразу развернуть исправление в продакшене, monkey patching может быть временным решением.
3. Расширение функциональности: Позволяет добавлять новые функции или изменять поведение существующего кода без изменения исходного кода.

```python
# Исходный модуль
class OriginalClass:
    def method(self):
        return "Original method"

# Monkey patching
def new_method(self):
    return "Patched method"

# Изменение метода класса
OriginalClass.method = new_method
# Использование измененного кода
obj = OriginalClass()
print(obj.method())  # Вывод: "Patched method"
```

## 16. В чем разница между `staticmethod` и `classmethod`?
| Параметр | Class Method | Static Method |
|----------|--------------|---------------|
| Декоратор | `@classmethod` | `@staticmethod` |
| Применение | Часто используется как фабричный метод для класса | Используется как вспомогательные функции |
| Область видимости | Привязан к классу, а не к объектам | Также привязан к классу, а не к объектам |
| Поведение | Может изменять состояние класса | Не может обращаться к состоянию класса |
| Параметр | Принимает `cls` в качестве первого параметра | Не имеет специфичных параметров |

```python
class Circle:
    no_of_circles = 0
    def __init__(self, radius):
        self.radius = radius
        Circle.no_of_circles += 1
        
    @staticmethod
    def square(num):
        return num**2
    
    @classmethod
    def getCircleCount(cls):
        return cls.no_of_circles
```

## 17. Для чего используется переменная с одним подчеркиванием `_` в Python?
Python автоматически сохраняет значение последнего выражения в интерпретаторе в переменной `_`.
```python
>>> 78 + 89
167
>>> _
167
```
Одиночное подчеркивание используется при распаковке, чтобы игнорировать значения.
```python
>>> a, _, b = (1, 12, 2)
>>> a, *_, b = (1, 12, 13, 14, 15, 16, 2)  # Нужны только первое и последнее значения
>>> a, *x, b = (1, 12, 13, 14, 15, 16, 2)  # Можно использовать любое имя
>>> _  # Возвращает список элементов
[12, 13, 14, 15, 16]
```
Часто используется в циклах, когда значение, возвращаемое итератором, не важно.
```python
for _ in range(5):
    print('Некоторые операции')
```
Примечание: Это соглашение, чтобы не создавать лишние переменные.

## 18. В чем разница между модулем и пакетом в Python?
### Модуль
Модуль — это файл Python с расширением `.py`, содержащий функции и глобальные переменные.
### Пакет
Пакет — это директория, содержащая модули и файл `__init__.py`, который интерпретатор распознает как пакет.

## 19. Что такое Global Interpreter Lock (GIL)?
(Ссылка: https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/)

## 20. Что быстрее: списковое включение или цикл `for`?
Списковые включения обычно быстрее циклов `for`, потому что они оптимизированы для выполнения одной операции над всеми элементами. Например, создание или обновление списка быстрее с использованием списковых включений.

## 21. Объясните Singleton класс и его применение.
(Ссылка: https://github.com/baliyanvinay/Python-Advanced/tree/main/Design%20Patterns)

## 22. Объясните метаклассы в Python.
В Python всё является объектом, даже класс — это объект. Поэтому класс также должен иметь тип. Все классы в Python имеют тип `type`. Даже класс `type` имеет тип `type`. Таким образом, `type` — это метакласс в Python, а для создания пользовательского метакласса нужно наследоваться от `type`.

### Использование метаклассов
Метакласс — это класс класса. Класс является экземпляром метакласса. Метаклассы чаще всего используются как фабрики классов.  
Когда вы создаете объект, вызывая класс, Python создает новый класс (при выполнении оператора `class`), вызывая метакласс.

```python
>>> type(17)  # <class 'int'>
>>> type(int)  # <class 'type'>
>>> str.__class__  # <class 'type'>
>>> type.__class__  # <class 'type'>
```

### Вызов метакласса
Метакласс вызывается с:
- `name`: именем класса,
- `bases`: кортежем родительских классов (для наследования, может быть пустым),
- `attrs`: словарем с именами и значениями атрибутов.

```python
def init(self, make):
    self.make = make

# type(name, bases, attrs)
>>> Car = type('Car', (object,), {'__init__': init, '__repr__': lambda self: self.make, 'wheels': 4})
>>> seltos = Car('Kia')
>>> seltos  # Kia
```

## 23. Лучший способ объединить n строк в одну.
Лучший способ объединения строк — использование `+` или `+=`, так как это читаемо и быстро. Однако во многих кодовых базах используют `append` и `join` для объединения строк, чтобы код был чище и понятнее.
```python
first_name = 'Max '
last_name = 'Verstappen'
full_name = first_name + last_name
# Использование метода join
full_name = ''.join((first_name, last_name))  # Принимает кортеж строк, если значений несколько
```

## 24. Кратко объясните функции `map()` и `lambda()`.
### `map(function, iterable)`
Функция `map` возвращает итератор, который применяет функцию к каждому элементу итерируемого объекта. Если передано несколько итерируемых объектов, итератор останавливается, когда самый короткий из них исчерпан.
```python
def custom_power(x, y):
    return x**y

values = [1, 2, 3, 4]
powers = [2, 1, 2] 
map_iterator = map(custom_power, values, powers)  # Пропустит степень для 4
print(list(map_iterator))  # [1, 2, 9]
```

### `lambda параметры: выражение`
Лямбда-выражение создает анонимную функцию. Функции, созданные с помощью лямбда-выражений, не могут содержать операторы или аннотации.
```python
>>> # lambda [список параметров] : выражение
>>> list(map(lambda x: x + 10, [1, 2, 3]))  # [11, 12, 13]
>>> func = lambda x: x + 10  # <function <lambda> at 0x7fdb99e9c310>
>>> func(25)  # Возвращает 35
>>> lambda: 'hello'  # Без параметров
```

## 25. Объясните абстрактные классы и их применение.
Абстрактный класс можно рассматривать как шаблон для других классов. Он позволяет создать набор методов, которые должны быть реализованы в дочерних классах. Или, в более общем смысле, класс, содержащий один или более абстрактных методов, называется абстрактным классом.  
По умолчанию Python не предоставляет абстрактных классов, но модуль `ABC` можно использовать для их определения.

### Абстрактный метод
Абстрактный метод — это метод, который объявлен, но не реализован. Это гарантирует, что любой класс, созданный на основе этого класса, должен реализовать этот метод.
```python
from abc import ABC, abstractmethod
class DB_Plugin(ABC):
    @abstractmethod
    def add_source(self):
        pass
```

## 26. Объясните процесс создания объекта. Какой метод вызывается первым?
При создании объекта класса или инстанцировании класса сначала вызывается метод `__new__()`. Этот метод отвечает за возврат нового объекта класса. Его можно переопределить для ограничений при создании объектов.  
- Конструктор класса — это `__new__()`,
- Инициализатор класса — это `__init__()`.  
Инициализатор вызывается сразу после конструктора, но если конструктор не вернул объект класса, вызов инициализатора бесполезен.  
Примечание: `__init__()` может использовать объект класса (`self`) для инициализации, потому что к моменту вызова `__init__()` объект уже создан.

## 27. Разница между переменной класса и переменной экземпляра.
| Параметр | Переменная класса | Переменная экземпляра |
|----------|-------------------|-----------------------|
| Объявление | Внутри определения класса, но вне методов экземпляра | Внутри метода `__init__` |
| Область видимости | Общая для всех объектов | Принадлежит конкретному экземпляру |
| Поведение | Изменения отражаются на всех экземплярах | Изменения затрагивают только экземпляр |
| Доступ | `cls.variable_name` | `self.variable_name` |

```python
class Car:
    total_cars, wheels = 0, 4
    def __init__(self, engine_power):
        self.engine_power = engine_power
        Car.total_cars += 1  # Увеличивается при создании новой машины
        
kia_sonet = Car(120)
print(kia_sonet.wheels)  # 4
kia_sonet.wheels += 1  # Добавляем колесо
print(kia_sonet.wheels)  # 5

print(Car.total_cars)  # 1
print(Car.wheels)  # 4, а не 5
Car.wheels = 6  # Добавляем два колеса

print(kia_sonet.wheels)  # Теперь 6
```

## 28. Объясните концепцию словаря в Python.
- Словарь состоит из набора пар ключ-значение. Каждая пара ключ-значение отображает ключ на связанное с ним значение.
- Ключ может встречаться в словаре только один раз. Дубликаты ключей не допускаются.
- Использование ключа дважды при создании словаря перезапишет первое значение.
- Ключ должен быть неизменяемым типом. Значения могут быть любыми.

```python
>>> dict_sample_01 = {1: 12, 2: 14, 1: 16}
>>> dict_sample_01  # {1: 16, 2: 14}
>>> dict_sample_02 = dict.fromkeys('123')
>>> dict_sample_02  # {'1': None, '2': None, '3': None}
```

## 29. Разница между выражением и оператором в Python.
Оператор — это полная строка кода, которая выполняет какое-то действие, а выражение — это любой участок кода, который вычисляется в значение. Выражение также является оператором.  
Лямбда-функции в Python принимают только выражения.

## 30. Объясните потоки (threading) в Python.
(Оставлено для подробного изучения)

## 31. Могут ли списки быть элементами множества?
Нет, нельзя добавить список в множество, потому что списки изменяемы, и их содержимое может измениться после добавления в множество. Однако можно добавлять кортежи, так как они неизменяемы.  
Объекты должны быть хешируемыми, чтобы операции поиска, добавления и удаления выполнялись быстрее, чем при проверке каждого элемента.  
Некоторые неизменяемые типы:
- Список: используйте кортеж.
- Множество: используйте `frozenset`.

## 32. Возможна ли перегрузка методов в Python?
Да, перегрузка методов возможна в Python. Её можно достичь, используя разное количество аргументов.
```python
def increment(value, by=1):
   return value + by

# Вызов функции
increment(5)  # 6
increment(5, 2)  # 7
```

## 33. Объясните наследование в Python.
![Наследование в Python](https://github.com/baliyanvinay/Python-Interview-Preparation/blob/main/Inheritance.png)

## 34. Объясните порядок разрешения методов (MRO) при множественном наследовании.
(Оставлено для подробного изучения)

## 35. Что может быть ключом в словаре?
Любой неизменяемый тип данных может быть ключом словаря, даже функции и классы.  
#### Почему список или другой словарь (изменяемые объекты) не могут быть ключами?
Реализация словаря снижает среднюю сложность поиска до O(1), требуя, чтобы ключи предоставляли хеш-функцию. Хеш-функция берет информацию из ключа и производит целое число (хеш-значение), которое определяет "корзину" для пары ключ-значение. Изменяемые объекты, такие как списки или словари, не могут предоставить валидный метод `__hash__`.

## 36. Объясните поверхностное и глубокое копирование в Python.
Для изменяемых коллекций или коллекций, содержащих изменяемые элементы, иногда нужно копирование, чтобы изменять одну копию, не затрагивая другую.  
Python компилирует исходный код в байт-код, затем интерпретирует его на виртуальной машине. Файл `.pyc` содержит байт-код.
```python
>>> import copy
>>> sample_1 = [1, 2, 3]
>>> id(sample_1)
139865052152768
>>> sample_2 = sample_1
>>> id(sample_2)
139865052152768
>>> sample_3 = copy.copy(sample_1)
>>> id(sample_3)
139865052236736
```
- Поверхностная копия создает новый составной объект и вставляет ссылки на объекты из оригинала.
- Глубокая копия создает новый составной объект и рекурсивно вставляет копии объектов из оригинала.

## 37. Почему Python создает файл `.pyc`, если это интерпретируемый язык?
Файлы `.pyc` создаются интерпретатором Python при импорте `.py` файлов и содержат "скомпилированный байт-код" импортированного модуля/программы. Идея в том, что "трансляция" из исходного кода в байт-код (которая выполняется один раз) может быть пропущена при последующих импортах, если `.pyc` новее соответствующего `.py` файла, что ускоряет запуск. Но код все равно интерпретируется.

## 38. Как объявляются приватные переменные в Python?
В Python нет приватных членов, но по соглашению два подчеркивания перед переменной или функцией делают её приватной.
```python
class XSpecial:
    normal_var = 10
    __private_var = 17

>>> special_obj = XSpecial()
>>> special_obj.normal_var
>>> special_obj.__private_var  # AttributeError
```

## 39. Разница между массивом и списком.
| Список | Массив |
|--------|--------|
| Может содержать элементы разных типов | Содержит элементы одного типа |
| Не требует импорта | Требует импорта (numpy или array) |
| Предпочтителен для коротких последовательностей | Предпочтителен для больших последовательностей (анализ данных) |
| Нельзя выполнять арифметические операции над всем списком | Подходит для арифметических операций |

## 40. Что такое итератор? Чем итератор отличается от генератора?
Итератор — это объект, реализующий `__next__`, который должен возвращать следующий элемент итерируемого объекта или вызывать исключение `StopIteration`, если элементов больше нет.
### Разница между итератором и генератором
| Итератор | Генератор |
|----------|----------|
| Класс используется для реализации итератора | Функция используется для реализации генератора |
| Использует `iter()` и `next()` | Использует `yield` |
| Не каждый итератор — генератор | Каждый генератор — итератор |
| Эффективен по памяти | Требует больше памяти |

## 41. Как определить словарь, где несколько ключей имеют одно значение?
```python
products = {}
products.update(
    dict.fromkeys(['Apple', 'Mango', 'Oranges'], 20)
)
products.update(
    dict.fromkeys(['Pizza', 'Kind Pizza', 'Bad Pizza'], 30)
)
```

## 42. Какие бывают пространства имен в Python?
Пространство имен — это способ реализации области видимости. В Python каждому пакету, модулю, классу, функции и методу принадлежит "пространство имен", в котором разрешаются имена переменных. Также есть глобальное пространство имен, используемое, если имя не найдено в локальном.  
Каждое имя переменной проверяется в локальном пространстве имен (тело функции, модуля и т. д.), а затем в глобальном.
### Типы пространств имен
- **Локальное пространство имен**: Создается при вызове функции и удаляется при возврате или необработанном исключении.
- **Глобальное пространство имен**: Создается при чтении определения модуля и обычно существует до завершения интерпретатора.
- **Встроенное пространство имен**: Создается при запуске интерпретатора Python и никогда не удаляется.

## 43. Как получить доступ к атрибуту родительского класса, если в дочернем классе есть атрибут с тем же именем?
```python
class Parent:
    variable = 12
    
class Derived(Parent):
    variable = 10

Parent.variable  # 12
```

## 44. Вычисление булевых выражений.
- Выражение `x and y` сначала вычисляет `x`; если `x` ложно, возвращается его значение; иначе вычисляется `y` и возвращается его значение.
- Выражение `x or y` сначала вычисляет `x`; если `x` истинно, возвращается его значение; иначе вычисляется `y` и возвращается его значение.
```python
x = 'Some Value'
y = 24
z = False
x or y  # Возвращает x
z or y  # Возвращает y
x and y  # Возвращает y
z and x  # Возвращает z
```

## 45. Разница между многопроцессорностью и многопоточностью.
Модуль `threading` использует потоки, а `multiprocessing` — процессы. Разница в том, что потоки используют общее пространство памяти, а процессы — отдельное. Это усложняет обмен объектами между процессами. Поскольку потоки используют общую память, нужно принимать меры, чтобы два потока не записывали в одну память одновременно.  
- Многопоточность — это конкурентность, используется для задач, связанных с вводом-выводом.
- Многопроцессорность обеспечивает истинный параллелизм и используется для задач, связанных с процессором.  
Используйте многопоточность, если задача связана с ожиданием API-вызовов, чтобы не простаивать в ожидании.

## 46. Как объединить два словаря?
```python
first_dict = {'name': 'Tom', 'age': 44}
second_dict = {'occupation': 'actor', 'nationality': 'British'}
# Объединение
final_dict = {**first_dict, **second_dict}
```
Если ключ есть в обоих словарях, приоритет имеет значение из второго словаря.

## 47. Как перегрузить конструктор Python?
(Оставлено для подробного изучения)

## 48. Объясните следующий код:
```python
def func(sample_list=[]):
    sample_list.append(12)
    # print(id(sample_list))
    return sample_list

print(func())  # [12]
print(func())  # [12, 12]
```
Поскольку список изменяем, при первом вызове `func` он пуст, но при повторном вызове список уже содержит элемент. Можно убедиться в этом, напечатав `id` списка — при каждом вызове он будет одинаковым.

## 49. Пример `filter` с лямбда-выражением.
### `filter`
`filter(function, iterable)` # Функция должна возвращать `True` или `False`
```python
input_list = ['Delhi', 'Mumbai', 'Noida', 'Gurugram']
to_match = 'Gurugram'
 
matched