### 2. "Магические" методы (Dunder Methods)
Понимание и умение применять эти методы — признак глубокого знания языка.

*   **Обязательные к знанию:** `__init__`, `__new__` (и разница между ними!), `__str__` vs `__repr__`.
*   **Для управления контекстом:** `__enter__`, `__exit__` (для менеджеров контекста).
*   **Для создания коллекций:** `__getitem__`, `__setitem__`, `__len__`, `__iter__`, `__next__`.
*   **Для сравнения объектов:** `__eq__`, `__lt__`, `__hash__`.
*   **Для эмуляции callable-объектов:** `__call__`.
*   **Для управления атрибутами (продвинутая тема):** `__getattr__`, `__getattribute__`, `__setattr__`, `__delattr__`. Понимание их влияния на производительность и потенциальных рекурсий.

Отличный список. Понимание этих методов — это именно то, что отделяет миддла от сеньора, так как они позволяют глубоко интегрировать свои объекты в экосистему Python, делая их идиоматичными и удобными.

---

### Обязательные к знанию: Основы жизненного цикла и представления

*   **`__init__(self, ...)`**: **Инициализатор.** Вызывается после создания объекта. Его задача — привести объект в валидное, готовое к использованию состояние, инициализировав его атрибуты. Это не создание объекта, а его "настройка".
*   **`__new__(cls, ...)`**: **Конструктор.** Статический метод (но декорировать не нужно), который вызывается *до* `__init__`. Его задача — **создать и вернуть новый экземпляр** класса. Принимает класс `cls` первым аргументом.
    *   **Ключевая разница:** `__new__` управляет созданием экземпляра, `__init__` — его инициализацией.
    *   **Когда переопределять `__new__`?**
        1.  **Наследование от неизменяемых типов** (например, `str`, `int`, `tuple`). Так как их состояние нельзя изменить в `__init__`, вся работа должна быть done в `__new__`.
        2.  **Реализация паттерна Синглтон** (хотя это часто антипаттерн в Python [[Singleton]]).
        3.  **Создание экземпляра другого типа** (например, фабричный метод внутри класса).

    **Пример с наследованием от `str`:**
    ```python
    class UpperStr(str):
        def __new__(cls, value):
            # Создаем новый экземпляр str с преобразованной value
            instance = super().__new__(cls, value.upper())
            return instance

        # __init__ не нужен, т.к. str неизменяемый и уже создан в __new__

    my_str = UpperStr('hello') # 'HELLO'
    ```

*   **`__str__(self)`**: Для "неформального" строкового представления, ориентированного на пользователя. Вызывается `str(obj)`, `print(obj)`, в f-строках `f"{obj}"`. Должен быть читаемым и человеко-ориентированным.
*   **`__repr__(self)`**: Для "формального" строкового представления, ориентированного на разработчика. Это часто должен быть валидный код на Python, который позволил бы воссоздать такой же объект. Вызывается `repr(obj)`, а также попадает в REPL и отладочный вывод. Если `__str__` не реализован, используется `__repr__` как fallback.

    **Золотое правило:** `__repr__` для разработчиков (дебаг, логи), `__str__` для пользователей (интерфейс).
    ```python
    class Point:
        def __init__(self, x, y):
            self.x = x
            self.y = y

        def __str__(self):
            return f"Point({self.x}, {self.y})"

        def __repr__(self):
            return f"Point(x={self.x}, y={self.y})"

    p = Point(1, 2)
    print(p)        # Point(1, 2) -> __str__
    print(repr(p))  # Point(x=1, y=2) -> __repr__
    ```

---

### Для управления контекстом: Менеджеры контекста

*   **`__enter__(self)`**: Вызывается при входе в блок `with`. Возвращаемое значение绑定тся к переменной после `as`.
*   **`__exit__(self, exc_type, exc_val, exc_tb)`**: Вызывается при выходе из блока `with` (нормальном или из-за исключения).
    *   `exc_type`: Тип исключения (или `None`).
    *   `exc_val`: Экземпляр исключения (или `None`).
    *   `exc_tb`: Объект трассировки (traceback) (или `None`).
    *   **Если метод возвращает `True`**, исключение (если было) считается обработанным и не пробрасывается дальше. Если возвращает `False` (или `None`) — исключение пробрасывается.

    **Пример: Самодельный менеджер контекста для таймера**
    ```python
    import time

    class Timer:
        def __enter__(self):
            self.start = time.time()
            return self  # Будет присвоено в 't' в 'as t'

        def __exit__(self, *args):
            self.end = time.time()
            self.elapsed = self.end - self.start
            print(f"Elapsed time: {self.elapsed:.2f} seconds")

    with Timer() as t:
        time.sleep(1)
    # После выхода из блока автоматически выведет время
    ```

---

### Для создания коллекций: Эмуляция встроенных типов

Позволяют вашим объектам работать как стандартные списки, словари или итерируемые объекты.

*   **`__len__(self)`**: Вызывается `len(obj)`. Должен возвращать неотрицательное целое число.
*   **`__getitem__(self, key)`**: Вызывается для получения элемента по ключу/индексу: `obj[key]`.
*   **`__setitem__(self, key, value)`**: Вызывается для присвоения значения по ключу/индексу: `obj[key] = value`.
*   **`__iter__(self)`**: Вызывается `iter(obj)` или в цикле `for`. Должен возвращать **итератор** (объект, у которого есть `__next__`). Часто бывает генератором.
*   **`__next__(self)`**: Реализуется в самом итераторе. Вызывается на каждой итерации, должен возвращать следующее значение или вызвать `StopIteration`.

    **Пример: Простая коллекция**
    ```python
    class MyCollection:
        def __init__(self, data):
            self.data = data

        def __len__(self):
            return len(self.data)

        def __getitem__(self, index):
            return self.data[index]

        def __iter__(self):
            # Простейший способ — сделать генератор
            for item in self.data:
                yield item
            # Или вернуть итератор от списка: return iter(self.data)

    coll = MyCollection([1, 2, 3])
    print(len(coll))    # 3 -> __len__
    print(coll[1])      # 2 -> __getitem__
    for item in coll:   # __iter__
        print(item)
    ```

---

### Для сравнения объектов: Протоколы сравнения и хеширования

*   **`__eq__(self, other)`**: Определяет поведение оператора `==`. По умолчанию (`object`) это проверка на `is` (совпадение идентификаторов).
*   **`__lt__(self, other)`**, **`__gt__`**, **`__le__`**, **`__ge__`**: Операторы `<`, `>`, `<=`, `>=`.
    *   **Протокол `@functools.total_ordering`**: Если определить хотя бы `__eq__` и один из `__lt__`, `__le__`, `__gt__`, или `__ge__`, этот декоратор автоматически сгенерирует остальные методы. **Экономит код и уменьшает вероятность ошибок.**
*   **`__hash__(self)`**: Вызывается `hash(obj)`. Необходим, чтобы объект можно было использовать как ключ словаря или элемент множества.
    *   **Важнейшее правило:** Если вы переопределяете `__eq__` для сравнения по значению, вы **обязаны** переопределить и `__hash__`. При этом объекты, которые равны (`a == b` -> `True`), должны иметь одинаковый хеш (`hash(a) == hash(b)`).
    *   Если `__eq__` определен, а `__hash__` не переопределен, Python сделает объект unhashable для вашей же безопасности.

    **Пример:**
    ```python
    from functools import total_ordering

    @total_ordering
    class Card:
        def __init__(self, rank, suit):
            self.rank = rank
            self.suit = suit

        def __eq__(self, other):
            # Сравниваем по значению, а не по id
            return self.rank == other.rank and self.suit == other.suit

        def __lt__(self, other):
            # Сравниваем сначала по rank, потом по suit
            if self.rank == other.rank:
                return self.suit < other.suit
            return self.rank < other.rank

        def __hash__(self):
            # Хеш должен быть основан на тех же атрибутах, что и __eq__
            return hash((self.rank, self.suit))

    # Теперь Card можно сравнивать и использовать в set/dict
    ace_spades = Card(12, 'spades')
    king_hearts = Card(11, 'hearts')
    print(ace_spades > king_hearts) # True
    hand = {ace_spades, king_hearts} # Работает благодаря __hash__
    ```

---

### Для эмуляции callable-объектов: Функторы

*   **`__call__(self, *args, **kwargs)`**: Позволяет экземпляру класса быть вызванным как функция: `instance()`.
    *   **Когда использовать?** Паттерн "Функтор" полезен, когда нужно сохранить **состояние** между вызовами.
    *   **Альтернативы:** Замыкания (closures) часто решают ту же задачу. Выбор между функтором и замыканием — вопрос стиля и сложности.

    **Пример: Счетчик вызовов**
    ```python
    class Counter:
        def __init__(self):
            self.count = 0

        def __call__(self, *args, **kwargs):
            self.count += 1
            print(f"Call count: {self.count}")

    c = Counter()
    c() # Call count: 1
    c() # Call count: 2
    ```

---

### Для управления атрибутами (Продвинутая тема!)

Эти методы — мощный, но опасный инструмент. Их неконтролируемое использование ломает ожидания и резко снижает читаемость и производительность кода.

*   **`__getattribute__(self, name)`**: Вызывается **при доступе к любому атрибуту** (даже к `self.__dict__`!). Это ловушка самого низкого уровня. Крайне легко создать бесконечную рекурсию.
    *   **Правило:** Всегда вызывайте `object.__getattribute__(self, name)` или `super().__getattribute__(name)` для базовой реализации.
    *   **Избегайте:** Используйте только если вам нужен абсолютный контроль над каждым обращением к атрибуту. Сильно бьет по производительности.

*   **`__getattr__(self, name)`**: Вызывается **только если атрибут не был найден стандартными способами** (через `__dict__`, через дескрипторы и т.д.). Это "fallback" для обработки отсутствующих атрибутов.
    *   **Основное применение:** Паттерн "Динамический прокси" или реализация удобного API (например, `obj.attr` вместо `obj.get_attr()`).

*   **`__setattr__(self, name, value)`**: Вызывается **при присвоении значения любому атрибуту** (`obj.attr = value`).
    *   **Опасность рекурсии:** Писать `self.name = value` внутри этого метода — классическая ошибка, ведущая к бесконечной рекурсии.
    *   **Правило:** Всегда используйте `self.__dict__[name] = value` или `object.__setattr__(self, name, value)`.

*   **`__delattr__(self, name)`**: Аналогичен `__setattr__`, но для удаления (`del obj.attr`).

**Пример (осторожно!): Логирование доступа к атрибутам**
```python
class LoggingProxy:
    def __init__(self, target):
        # object.__setattr__ чтобы избежать рекурсии в __setattr__
        object.__setattr__(self, '_target', target)

    def __getattr__(self, name):
        # Вызывается только если атрибута нет у самого proxy
        print(f"Getting attr: {name}")
        return getattr(self._target, name)

    def __setattr__(self, name, value):
        print(f"Setting attr: {name} = {value}")
        # Нельзя делать self.name = value!
        setattr(self._target, name, value)

    # __delattr__ опущен для краткости

class Data:
    def __init__(self, x):
        self.x = x

data = Data(10)
proxy = LoggingProxy(data)
proxy.x    # Вывод: Getting attr: x -> 10
proxy.y = 20 # Вывод: Setting attr: y = 20
```

**Итог для сеньора:** Магические методы — это способ говорить на одном языке с Python. Их грамотное применение делает код интуитивно понятным, лаконичным и мощным. Однако, с большой силой приходит и большая ответственность: особенно это касается методов доступа к атрибутам, которые должны использоваться обдуманно и только там, где без них действительно не обойтись.