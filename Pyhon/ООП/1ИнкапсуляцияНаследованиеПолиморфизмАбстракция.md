### 1. Фундаментальные концепции (на уровне "Почему?" и "Когда?")

Здесь вас будут проверять на понимание сути, а не на зазубривание определений.

* **Инкапсуляция:** Не просто "сокрытие данных". Обсуждение `public`, `protected` (`_`), `private` (`__`) аттрибутов. Понимание Name Mangling. **Главное:** когда и зачем использовать каждый из уровней доступа? Как это связано с поддержкой кода и контрактами класса?
* **Инкапсуляция** — это принцип сокрытия внутреннего состояния объекта и предоставления доступа к нему только через определенные методы, что защищает данные от прямого вмешательства и обеспечивает их целостность.


* **Наследование:** Глубокое понимание MRO (Method Resolution Order) в Python. Проблема ромбовидного наследования и как Python ее решает (`super()`). **Ключевой вопрос:** Композиция vs Наследование. Вы должны блестяще аргументировать, когда что использовать. Сеньоры почти всегда предпочитают композицию.

**Наследование** — это механизм в объектно-ориентированном программировании, который позволяет одному классу (наследнику) получать свойства и методы другого класса (родителя), повторно используя код и упрощая его расширение.

* **Полиморфизм:** Утиная типизация (Duck Typing) как основа полиморфизма в Python. Как создать абстрактный базовый класс (ABC) с помощью модуля `abc` (`ABCMeta`, `@abstractmethod`). Зачем это нужно для создания строгих интерфейсов.

**Полиморфизм** — это способность объектов разных классов реагировать на одинаковые методы по-своему, позволяя использовать единый интерфейс для работы с разными типами данных.

* **Абстракция:** Использование ABC для определения интерфейсов, которые должны быть реализованы дочерними классами. Это инструмент для проектирования крупных систем.

___
### 1. Инкапсуляция: Управление сложностью через контракты

**Суть:** Инкапсуляция — это не просто "сокрытие данных", а принцип **управления сложностью** и **установления контрактов**. Мы объединяем данные и методы, которые с ними работают, в одну единицу (класс) и четко определяем, *какая часть внутренней кухни является стабильным интерфейсом*, а какая — изменчивой реализацией.

**Уровни доступа и их применение (`public`, `protected`, `private`):**

*   **`public` (например, `self.name`)**: Это — **контракт** класса с внешним миром. Интерфейс, который мы гарантируем стабильным (или изменяемым по четким правилам семантического версионирования). Его изменение ломает обратную совместимость. Используется для функциональности, которая нужна клиентскому коду.
    *   *Когда использовать?* Всегда начинайте с `public`. Делайте методы и атрибуты публичными, если они являются частью преднамеренно спроектированного API вашего класса.

*   **`protected` (например, `self._internal_helper`)**: Это — **интерфейс для наследников** и, иногда, для "дружественных" классов внутри одного модуля/пакета. Это сигнал разработчику: "Вы можете использовать этот метод, но он не является частью публичного API и может измениться даже в минорной версии. Используйте на свой страх и риск".
    *   *Когда использовать?* Когда вы намеренно проектируете класс для наследования и хотите предоставить инструменты потомкам, но не хотите выносить эту функциональность в публичный интерфейс. Это смягченная версия `private`, которая признает, что наследование — это реальность.

*   **`private` (например, `self.__implementation_detail`)**: Это — **внутренняя реализация**. Жесткое ограничение доступа. Главная цель — предотвратить **случайные** конфликты имен в цепочке наследования (см. пример ниже) и четко обозначить, что эти атрибуты/методы абсолютно нестабильны и не предназначены для использования ни снаружи, ни в подклассах.
    *   *Когда использовать?* Для truly internal state и вспомогательных методов, которые не должны быть доступны никому, включая разработчиков подклассов. Используется реже, чем `protected`.

**Name Mangling (искажение имен):**
Механизм, реализующий `private` в Python. Интерпретатор преобразует имя `__private_var` внутри класса `ClassName` в `_ClassName__private_var`. Это не "безопасность", а синтаксический барьер.

**Пример конфликта, который решает `private`:**
```python
class A:
    def __init__(self):
        self.__x = 10  # Станет _A__x
        self._y = 20   # Останется _y

class B(A):
    def __init__(self):
        super().__init__()
        self.__x = 100 # Станет _B__x (другой атрибут!)
        self._y = 200  # Перезапишет _y из A

b = B()
print(b.__dict__) # {'_A__x': 10, '_y': 200, '_B__x': 100}
# Мы видим два разных атрибута __x и один перезаписанный _y.
```
**Итог для сеньора:** Инкапсуляция — это проектирование интерфейсов. `public` — это стабильный контракт, `protected` — нестабильный контракт для наследников, `private` — механизм для избежания конфликтов имен в сложных иерархиях. Зрелый разработчик сначала думает о том, какой API он предоставляет миру, а уже потом о том, как спрятать детали.

---

### 2. Наследование: Отношение "is-a" и элегантное разрешение методов

**Суть:** Механизм для создания иерархий типов по принципу **"is-a"** (является). `Dog` *is-a* `Animal`. Это мощный инструмент для повторного использования кода и выражения специализации.

**MRO (Method Resolution Order) и `super()`:**
Python использует алгоритм **C3** для построения линеаризованного порядка наследования. Это не просто "глубина", а гарантия монотонности, которая решает проблемы ромбовидного наследования.

**Ромбовидное наследование и как Python его решает:**
```python
class A:
    def run(self):
        print("A")

class B(A):
    def run(self):
        print("B")
        super().run()

class C(A):
    def run(self):
        print("C")
        super().run()

class D(B, C):
    def run(self):
        print("D")
        super().run()

d = D()
d.run()
```
**Вопрос: Что выведет код?**
Без C3 это была бы неоднозначность: идти сначала в `B` и потом в `A` (и пропустить `C`)? Или в `B`, потом в `C`, и только потом в `A`?

**Ответ Python (благодаря C3):**
```
D
B
C
A
```
**Почему?** MRO для класса `D` вычисляется как `[D, B, C, A, object]`. Вызов `super().run()` в `B` ведет не к родителю `A`, а к *следующему классу в MRO* — `C`. Это ключевая магия `super()`: он делегирует вызов *не родителю*, а *следующему в цепи*.

**Композиция vs Наследование ("Has-a" vs "Is-a"):**

Это **ключевой вопрос архитектуры**, по которому сразу виден уровень разработчика.

*   **Наследование** используйте, только когда отношение **строго подчиняется "is-a"** и вы хотите:
    *   Предоставлять интерфейс базового класса клиентскому коду (полиморфизм).
    *   Реализовать паттерн "Шаблонный метод", где базовый класс определяет скелет алгоритма.
    *   *Минусы:* Создает жесткую, тесную связь. Внутренние детали родителя становятся известны потомку. Может привести к вздутым иерархиям.

*   **Композиция (и агрегация)** — предпочтительный выбор в 90% случаев. Отношение **"has-a"** (имеет). `Car` *has-an* `Engine`.
    *   **Преимущества:**
        *   **Гибкость:** Вы можете динамически менять компоненты (`car.engine = TurboEngine()`).
        *   **Слабая связность:** Класс `Car` знает только об интерфейсе `Engine`, но не о его внутреннем устройстве.
        *   **Тестируемость:** Легко подменить реальный компонент mock-объектом.
        *   **Обходит ограничения единого наследования.**

**Правило для сеньора:** **Отдавайте предпочтение композиции.** Используйте наследование осознанно, только если новий класс *действительно является* более специализированной версией старого и вам критически важен полиморфизм. "Повторное использование кода" само по себе — слабая причина для наследования.

---

### 3. Полиморфизм: Интерфейс, а не тип

**Суть в Python:** Возможность работать с разными типами объектов единым образом, **если они реализуют ожидаемый интерфейс (метод)**. В Python полиморфизм основан на утиной типизации, а не на явном наследовании от общего предка (хотя это и возможно).

**Утиная типизация (Duck Typing):**
>"Если это ходит как утка и крякает как утка, то это и есть утка."

Коду не важен фактический тип объекта `obj`. Важно, чтобы у него был метод `obj.quack()`. Это делает код гибким и не привязанным к конкретным иерархиям.

**Абстрактные базовые классы (ABC) с модулем `abc`:**
Иногда утиная типизация слишком неформальна. Для явного определения **строгого интерфейса** используются ABC.

*   **Зачем?** Чтобы гарантировать, что все потомки реализовали *критически важные* методы *еще на этапе создания экземпляра*, а не в момент вызова отсутствующего метода.
*   **Как?** С помощью `ABCMeta` и декоратора `@abstractmethod`.

```python
from abc import ABCMeta, abstractmethod

class DataStream(metaclass=ABCMeta): # Интерфейс

    @abstractmethod
    def read(self, size: int) -> bytes:
        """Обязательный метод для всех потоков"""
        pass

    # Можно иметь реализованные методы (миксины)
    def read_all(self) -> bytes:
        chunks = []
        while chunk := self.read(1024):
            chunks.append(chunk)
        return b''.join(chunk)

class FileStream(DataStream):
    def __init__(self, filename):
        self.file = open(filename, 'rb')

    def read(self, size: int) -> bytes: # Должны реализовать!
        return self.file.read(size)

# Попытка создать экземпляр без read() приведет к TypeError
stream: DataStream = FileStream('data.bin')
data = stream.read_all() # Мы уверены, что read() существует.
```
**Итог для сеньора:** Полиморфизм в Python — это про интерфейсы. Утиная типизация обеспечивает гибкость, а ABC — строгость и безопасность на этапе проектирования для критически важных компонентов. Senior-разработчик использует ABC для явного описания контрактов в коде.

---

### 4. Абстракция: Проектирование интерфейсов

**Суть:** Абстракция — это процесс выделения **наиболее существенных характеристик** системы при одновременном игнорировании деталей реализации. В ООП инструментом для создания абстракций являются **интерфейсы**.

**Роль ABC в абстракции:**
ABC — это прямое воплощение абстракции в коде. Они позволяют:
1.  **Спроектировать архитектуру** на высоком уровне, определив, какие интерфейсы (`DataStream`, `Repository`, `Storage`) должны взаимодействовать друг с другом, не вдаваясь в реализацию (`PostgresRepository`, `S3Storage`).
2.  **Создать слой абстракции,** который инвертирует зависимости. Высокоуровневые модули зависят от абстракций (`abc.Repository`), а не от деталей низкого уровня (`concrete_impl.PostgresRepository`). Это прямое следование **принципу DIP (Dependency Inversion Principle)** из SOLID.
3.  **Обеспечить возможность подмены реализаций** (например, мок-хранилище для тестов или переход с одной СУБД на другую).

**Итог для сеньора:** Абстракция через ABC — это не академическая концепция, а **практический инструмент для построения сложных, гибких и тестируемых систем**. Senior-разработчик сначала думает об интерфейсах и контрактах между компонентами, а только потом о том, как их реализовать. Это позволяет управлять сложностью больших проектов и обеспечивать их долгосрочную поддерживаемость.



