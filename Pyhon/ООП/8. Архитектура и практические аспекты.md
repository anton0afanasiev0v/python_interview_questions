### 8. Архитектура и практические аспекты

* **Как вы принимаете решение о использовании ООП?** Когда ООП уместно, а когда лучше использовать функциональный подход или просто модули?
* **Наследование vs Композиция:** Это будет лейтмотивом многих вопросов. Готовьтесь с примерами.
* **Тестирование ООП-кода:** Как вы тестируете классы? Понимание Mock объектов и паттернов для облегчения тестирования (например, все тот же DI).
* **Антипаттерны:** God Object, нарушение инкапсуляции, глубокая иерархия наследования. Как их избежать.

Прекрасные вопросы! Они уводят обсуждение от сухой теории к практическому архитектурному мышлению, что как раз и отличает сеньора.

---

### **1. Как вы принимаете решение о использовании ООП?**

Решение не должно быть догмой "всегда ООП" или "никогда ООП". Выбор парадигмы зависит от решаемой задачи.

**ООП уместно, когда:**

1.  **Моделируются сложные сущности с состоянием и поведением:** Система естественным образом описывается как набор взаимодействующих объектов.
    *   *Пример:* Игра. `Player` имеет состояние (здоровье, инвентарь) и поведение (`move()`, `attack()`). `Enemy`, `Weapon` — это классические кандидаты в классы.
2.  **Требуется инкапсуляция:** Есть данные, которые должны быть защищены и изменяться только через строго определённый интерфейс.
    *   *Пример:* `BankAccount`. Прямое изменение баланса `account.balance = 1000` — это опасно. Правильнее: `account.deposit(1000)`.
3.  **Планируется активное повторное использование кода через наследование и полиморфизм:** Когда вы видите семейства объектов с общим поведением, но разной реализацией.
    *   *Пример:* Разные поставщики услуг (email, SMS, push). Общий интерфейс `NotificationSender` с методами `send()`, но разные реализации.
4.  **Архитектура строится вокруг паттернов проектирования:** Многие паттерны (Strategy, Observer, Factory) inherently объектно-ориентированы.

**Функциональный подход или модули уместны, когда:**

1.  **Задача ориентирована на преобразование данных, а не на имитацию жизни:** Программа — это конвейер (pipeline), где данные проходят через цепочку функций.
    *   *Пример:* Обработка данных (ETL), научные вычисления. `data = clean_data(normalize_data(load_data()))` или с использованием `map`, `filter`, `functools`.
2.  **Требуется предсказуемость и отсутствие побочных эффектов:** Функции, которые зависят только от своих аргументов и не изменяют внешнее состояние (чистые функции), проще тестировать и отлаживать.
3.  **Логика проста и не требует сложного состояния:** Не нужно создавать "квадратный класс" для круглой задачи.
    *   *Пример:* Набор утилитарных функций для работы со строками или математических вычислений. Это идеально укладывается в модуль `utils/helpers.py`.

**Практический вывод в Python:** Python — мультипарадигменный язык. **Используйте гибридный подход.** Часто лучшим решением является класс, который инкапсулирует состояние, но его методы реализованы в функциональном стиле (являются чистыми там, где это возможно). Не заставляйте себя использовать класс там, где достаточно функции.

---

### **2. Наследование vs Композиция**

Это фундаментальный выбор дизайна. Современная разработка склоняется в сторону композиции.

*   **Наследование (is-a):** Устанавливает тесную связь "является". `Dog` *is-a* `Animal`.
*   **Композиция (has-a):** Устанавливает слабую связь "имеет". `Car` *has-a* `Engine`.

**Проблемы наследования:**

1.  **Хрупкость базового класса:** Изменение в родительском классе может сломать работу всех дочерних классов.
2.  **Проблема ромбовидного наследования:** В Python она решается через C3 Linearization (MRO), но это усложняет дизайн.
3.  **Нарушение инкапсуляции:** Дочерний класс знает о деталях реализации родителя.

**Преимущества композиции:**

1.  **Гибкость:** Поведение можно динамически менять во время выполнения, подменяя компоненты.
2.  **Слабая связанность:** Класс ничего не знает о внутреннем устройстве своих компонентов, только об их интерфейсе.
3.  **Соблюдение SRP:** Каждый компонент отвечает за одну узкую задачу.

**Правило:** **Отдавайте предпочтение композиции перед наследованием.** Используйте наследование только тогда, когда между классами действительно есть отношения подтипа (соблюдается LSP) и вы хотите реализовать полиморфизм.

**Пример:**

```python
# НАСЛЕДОВАНИЕ (менее гибко)
class ReportGenerator:
    def generate(self, data):
        # ... базовая логика ...
        return self.format_report(data)

    def format_report(self, data): # Метод, который будут переопределять наследники
        raise NotImplementedError

class HTMLReportGenerator(ReportGenerator):
    def format_report(self, data):
        return f"<html><body>{data}</body></html>"

# КОМПОЗИЦИЯ (более гибко)
class ReportGenerator:
    def __init__(self, formatter): # Зависимость внедряется извне
        self._formatter = formatter

    def generate(self, data):
        # ... базовая логика ...
        return self._formatter.format(data) # Используем переданный форматтер

class HTMLFormatter:
    def format(self, data):
        return f"<html><body>{data}</body></html>"

class JSONFormatter:
    def format(self, data):
        import json
        return json.dumps(data)

# Теперь мы можем легко менять формат, не создавая новых иерархий
html_report = ReportGenerator(HTMLFormatter())
json_report = ReportGenerator(JSONFormatter())

# И даже менять поведение на лету
json_report._formatter = HTMLFormatter()
```

---

### **3. Тестирование ООП-кода**

**Основные принципы:**

1.  **Тестируйте публичный интерфейс:** Не тестируйте приватные методы (`_method`) напрямую. Они должны быть протестированы через публичные методы, которые их используют.
2.  **Изолируйте тесты:** Тест одного класса не должен зависеть от работы других классов или внешних ресурсов (БД, сеть). Здесь на помощь приходят **Mock-объекты**.
3.  **Используйте Dependency Injection:** Это главный паттерн, облегчающий тестирование.

**Mock-объекты (с помощью `unittest.mock`):** Это объекты-заглушки, которые имитируют поведение реальных объектов, позволяя проверить, *как* тестируемый код с ними взаимодействовал (вызывал ли нужные методы с правильными аргументами).

**Пример тестирования с Mock и DI:**

```python
# production_code.py
class EmailService:
    def send_welcome_email(self, user_email):
        # Сложная логика отправки email через SMTP
        print(f"Real email sent to {user_email}") # В тесте этого быть не должно

class UserService:
    def __init__(self, email_service: EmailService): # DI!
        self.email_service = email_service

    def register_user(self, user_email):
        # ... логика регистрации ...
        self.email_service.send_welcome_email(user_email) # Важно протестировать этот вызов

# test_code.py
from unittest.mock import Mock
from production_code import UserService

def test_user_registration_sends_email():
    # 1. Arrange (Подготовка)
    mock_email_service = Mock() # Создаем mock вместо реального EmailService
    user_service = UserService(email_service=mock_email_service)

    # 2. Act (Действие)
    test_email = "test@example.com"
    user_service.register_user(test_email)

    # 3. Assert (Проверка)
    # Утверждаем, что метод send_welcome_email был вызван ровно 1 раз с нужным аргументом
    mock_email_service.send_welcome_email.assert_called_once_with(test_email)
    # Реальный EmailService.send_welcome_email НИКОГДА не вызывался.
```

---

### **4. Антипаттерны**

1.  **God Object (Божественный объект):**
    *   **Что это:** Один класс, который "знает и умеет слишком много", нарушая SRP. Он контролирует половину системы и имеет тысячи строк кода.
    *   **Как избежать:** Дробить ответственность. Следовать SRP. Задавайте вопрос: "Сколько причин для изменения у этого класса?" Если больше одной — пора рефакторить.

2.  **Нарушение инкапсуляции:**
    *   **Что это:** Использование публичных атрибутов, когда нужны свойства (`@property`), или предоставление наружу mutable-объектов (например, возврат ссылки на внутренний список без копирования).
    *   **Как избежать:** Сделать атрибуты приватными (`_attr`), использовать `@property` для контролируемого доступа. Возвращать копии mutable-коллекций.

    ```python
    # ПЛОХО: нарушение инкапсуляции
    class BadClass:
        def __init__(self):
            self.my_list = [] # Публичный mutable-атрибут

    # ХОРОШО: инкапсуляция
    class GoodClass:
        def __init__(self):
            self._my_list = [] # Защищенный атрибут

        @property
        def my_list(self):
            # Возвращаем копию, чтобы исходный список нельзя было изменить извне
            return self._my_list.copy()
    ```

3.  **Глубокая иерархия наследования:**
    *   **Что это:** Цепочка наследования в 5+ классов. Сложно понять, какой метод откуда вызывается, легко сломать поведение в одном из middle-классов.
    *   **Как избежать:** **"Favor composition over inheritance"**. Вместо создания глубокой иерархии (`Vehicle -> Car -> PassengerCar -> Sedan`) используйте композицию признаков (`Sedn` *has* `Engine`, `Transmission`, `BodyStyle`).