### 3. Метаклассы (Metaclasses)
**Это must-have для сеньора.** Вас спросят не "что это", а "зачем это" и "когда это последнее средство".

*   Понимание, что такое метакласс (`type`).
*   Как создать свой метакласс (наследование от `type`).
*   Практические кейсы применения: регистрация классов, проверка структуры классов (например, чтобы все методы интерфейса были реализованы), автоматическое добавление атрибутов.
*   **Главный вопрос:** Почему в 99% случаев вместо метакласса лучше использовать декораторы классов? Вы должны уметь это объяснить.

Отлично, это именно тот уровень вопросов, который задают на senior-интервью. Ответы должны демонстрировать не только знание синтаксиса, но и глубокое понимание философии Python и компромиссов.

---

### Понимание: Что такое метакласс?

**Простое определение:** Метакласс — это «класс класса». Это объект, который контролирует создание класса (так же, как класс контролирует создание своего экземпляра).

**Техническое определение:** В Python всё является объектом. Каждый класс является объектом *какого-то метакласса*. Стандартным метаклассом для всех классов является `type`.

```python
# Классическое создание класса
class MyClass:
    pass

# Это syntactic sugar для следующего:
MyClass = type('MyClass', (), {})
# type(имя_класса, кортеж_родителей, словарь_атрибутов)

print(type(MyClass)) # <class 'type'>
print(type(int))     # <class 'type'>
```
**Вывод:** `type` — это метакласс, экземплярами которого являются все классы (включая сам `type`).

---

### Как создать свой метакласс

Собственный метакласс создается путем наследования от `type` и переопределения его методов. Ключевые методы:

*   **`__new__(mcs, name, bases, namespace, **kwargs)`**: Создает и возвращает новый класс. Это этап, на котором можно изменить пространство имен (`namespace`) до создания самого класса.
*   **`__init__(cls, name, bases, namespace, **kwargs)`**: Инициализирует только что созданный класс `cls`. Аналогичен `__init__` для обычных классов.
*   **`__prepare__(mcs, name, bases, **kwargs)`** (опционально): Возвращает объект, который будет использоваться как пространство имен (`namespace`) при выполнении тела класса. По умолчанию это обычный словарь. Полезно, если нужно сохранить порядок объявления атрибутов (возвращают `collections.OrderedDict`).

**Пример простого метакласса, который добавляет к имени каждого атрибута префикс:**
```python
class PrefixMeta(type):
    def __new__(mcs, name, bases, namespace, **kwargs):
        # Создаем новое пространство имен с префиксом
        prefixed_namespace = {}
        for attr_name, attr_value in namespace.items():
            if not attr_name.startswith('__'): # Не трогаем "магию"
                prefixed_namespace['prefixed_' + attr_name] = attr_value
            else:
                prefixed_namespace[attr_name] = attr_value

        # Создаем класс с модифицированным пространством имен
        return super().__new__(mcs, name, bases, prefixed_namespace)

class MyClass(metaclass=PrefixMeta):
    x = 1
    def method(self):
        pass

print(MyClass.__dict__.keys())
# dict_keys(['__module__', '__dict__', 'prefixed_x', 'prefixed_method', ...])
# original 'x' и 'method' были переименованы
```

---

### Практические кейсы применения (когда это оправдано)

1.  **Валидация и проверка структуры классов (самый сильный кейс):**
    Создание фреймворков с строгими контрактами. Метакласс может проверить, что класс, объявляющий себя реализацией интерфейса, действительно переопределил все необходимые методы.

   ```python
    class ValidatedInterface(type):
        def __new__(mcs, name, bases, namespace, **kwargs):
            cls = super().__new__(mcs, name, bases, namespace)
            # Проверяем, что класс реализует обязательные методы
            if not name.startswith('Abstract'):  # Пропускаем абстрактные классы
                if not hasattr(cls, 'save') or not callable(getattr(cls, 'save')):
                    raise TypeError(f"Class {name} must implement a 'save' method.")
            return cls

    class AbstractModel(metaclass=ValidatedInterface):
        pass

    class User(AbstractModel):
        # Забудем реализовать save...
        pass

    # TypeError: Class User must implement a 'save' method.
    ```

2.  **Регистрация классов (Registry Pattern):**
    Автоматическая регистрация всех классов, наследующих от определенной базы, в каком-либо реестре. Полезно для плагинов или фабрик.

    ```python
    class PluginRegistry(type):
        registry = {}  # Глобальный реестр всех плагинов

        def __new__(mcs, name, bases, namespace, **kwargs):
            cls = super().__new__(mcs, name, bases, namespace)
            # Регистрируем класс, если он не является базовым
            if not namespace.get('is_abstract'):
                mcs.registry[cls.__name__] = cls
            return cls

    class BasePlugin(metaclass=PluginRegistry):
        is_abstract = True  # Помечаем базовый класс как абстрактный

    class EmailPlugin(BasePlugin):
        pass

    class SMSSPlugin(BasePlugin):
        pass

    print(PluginRegistry.registry) # {'EmailPlugin': <class ...>, 'SMSSPlugin': <class ...>}
    ```

3.  **Автоматическое добавление/модификация атрибутов:**
    Как в примере с префиксом выше. Или, например, автоматическая генерация `__slots__` на основе аннотаций.

---

### Главный вопрос: Почему в 99% случаев лучше использовать декораторы классов?

Это **критически важный** вопрос, который проверяет, понимаете ли вы не только мощь, но и *опасность* метаклассов.

**Ответ Senior-разработчика:**

Метаклассы — это мощный, но сложный и "тяжелый" инструмент, который следует использовать только как **последнее средство (last resort)**. В большинстве задач, для которых рассматриваются метаклассы, декораторы классов являются более подходящим и Pythonic-решением.

**Почему декораторы лучше:**

1.  **Явность против магии (Explicit is better than implicit):**
    Декоратор — это явно указанный модификатор прямо над объявлением класса. Его действие очевидно и локализовано. Метакласс же — это "скрытая магия", его поведение неочевидно при чтении кода класса, особенно если он указан в глубине иерархии наследования.

2.  **Композиция против наследования:**
    На класс можно наложить несколько декораторов, комбинируя их функциональность. У класса же может быть **только один метакласс** (из-за проблем с наследованием, если родители имеют разные метаклассы). Это ограничивает гибкость.

3.  **Сложность и читаемость:**
    Код метаклассов, особенно с использованием `__prepare__`, часто бывает сложным для понимания и отладки. Декораторы, будучи обычными функциями, концептуально проще. Их легче написать, протестировать и понять коллегам.

4.  **Меньшая связанность (Loose Coupling):**
    Декоратор оборачивает уже готовый, сформированный класс. Метакласс же активно участвует в самом процессе создания класса, что создает более тесную и сложную связь.

**Когда метакласс все-таки нужен?**
Только когда вам нужно повлиять на **сам фундаментальный процесс создания класса**, а не на его готовый результат. Основные сценарии:

*   **Вам необходимо изменить пространство имен (namespace) *до* того, как класс будет создан.** Декоратор работает с уже готовым классом.
*   **Вы создаете DSL (Domain-Specific Language) или сложный фреймворк**, где требуется тотальный контроль над жизненным циклом класса (например, ORM типа Django ORM или SQLAlchemy, которые используют метаклассы для маппига таблиц).
*   **Вам нужна проверка/модификация на уровне всей иерархии классов**, которую невозможно elegantly сделать постфактум.

**Итоговое правило (Zen of Python для сеньора):**
> "Если твоя задача решается простым декоратором класса — используй декоратор. Прибегай к метаклассам только в тех исключительных случаях, когда декоратор физически не может решить поставленную задачу, и будь готов аргументировать, почему это так."


