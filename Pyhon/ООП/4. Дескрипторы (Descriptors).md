### 4. Дескрипторы (Descriptors)

Еще одна мощная и часто спрашиваемая продвинутая тема.

* Протокол дескриптора: `__get__`, `__set__`, `__delete__`.
* Различие между Data и Non-Data дескрипторами и их влияние на поиск атрибутов.
* Практическое применение: валидация данных, создание `@property`-подобных атрибутов с переиспользуемой логикой, ленивые вычисления.
* Понимание, что `@property`, `@classmethod`, `@staticmethod` — это реализовано через дескрипторы.

_________________________________________________________________

Безусловно. Понимание дескрипторов — это один из ключевых признаков глубокого знания Python. Это не просто синтаксис, а понимание фундаментального механизма, лежащего в основе многих "магических" возможностей языка.

---

### Протокол дескриптора

Дескриптор — это любой объект, который реализует *хотя бы один* из методов протокола:
*   **`__get__(self, instance, owner=None)`**: Вызывается для получения значения. `instance` — это экземпляр владельца (или `None`, если доступ идет через класс). `owner` — это сам класс-владелец.
*   **`__set__(self, instance, value)`**: Вызывается для установки значения.
*   **`__delete__(self, instance)`**: Вызывается для удаления атрибута.

**Важно:** Объект должен быть определен на уровне *класса*, чтобы механизм дескрипторов заработал.

**Простой пример дескриптора:**
```python
class VerboseAttribute:
    def __get__(self, instance, owner):
        print(f"Getting the value from {instance} of class {owner}")
        return "42"  # Какое-то вычисленное значение

    def __set__(self, instance, value):
        print(f"Setting the value for {instance} to {value}")
        # Здесь могла бы быть логика валидации или преобразования
        # Но в этом примере мы просто печатаем

class MyClass:
    attribute = VerboseAttribute()  # Дескриптор объявлен на уровне класса

obj = MyClass()
x = obj.attribute  # Вывод: Getting the value from <__main__.MyClass object...> of class <class '__main__.MyClass'>
# x = "42"
obj.attribute = 100 # Вывод: Setting the value for <__main__.MyClass object...> to 100
```

---

### Data vs Non-Data дескрипторы и поиск атрибутов

Это **критически важное различие**, которое определяет приоритет при поиске атрибута в цепочке `obj.attr`.

1.  **Data Descriptor (Дескриптор данных):** Реализует **`__set__`** или **`__delete__`**.
    *   **Высший приоритет.** Если у объекта есть атрибут, который является data-дескриптором в его классе, механизм поиска Python **всегда** вызовет `__get__` (или `__set__`) этого дескриптора, *игнорируя* значение из `obj.__dict__`.
    *   *Пример:* `@property` — это data-дескриптор.

2.  **Non-Data Descriptor (Дескриптор не-данных):** Реализует **только `__get__`**.
    *   **Низший приоритет.** Если в `obj.__dict__` уже есть атрибут с таким именем, он **перекроет** non-data дескриптор. Механизм дескрипторов будет вызван, только если атрибута нет в экземпляре.
    *   *Пример:* `@classmethod`, `@staticmethod` — это non-data дескрипторы.

**Алгоритм поиска `obj.attr` (упрощенно):**
1.  Проверить, есть ли `attr` в классе `obj` и является ли он **data-дескриптором**? Если да — вызвать `attr.__get__(obj, type(obj))`.
2.  Если нет — проверить, есть ли `attr` в `obj.__dict__`? Если да — вернуть это значение.
3.  Если нет — проверить, есть ли `attr` в классе `obj` и является ли он **non-data дескриптором** или обычным атрибутом? Для non-data дескриптора — вызвать `__get__`, для обычного атрибута — вернуть его.
4.  Продолжить поиск в родительских классах.

**Пример, демонстрирующий разницу:**
```python
class DataDescriptor:
    def __get__(self, instance, owner):
        return "DataDescriptor: __get__"
    def __set__(self, instance, value):
        print(f"DataDescriptor: __set__({value})")

class NonDataDescriptor:
    def __get__(self, instance, owner):
        return "NonDataDescriptor: __get__"

class TestClass:
    data_attr = DataDescriptor()
    non_data_attr = NonDataDescriptor()

obj = TestClass()

# Data Descriptor имеет высший приоритет
print(obj.data_attr) # DataDescriptor: __get__
obj.data_attr = 100  # DataDescriptor: __set__(100)
obj.__dict__['data_attr'] = 'value in instance dict' # Напрямую запишем в __dict__
print(obj.data_attr) # DataDescriptor: __get__ (ВСЕ ЕЩЕ вызывает дескриптор!)

# Non-Data Descriptor имеет низший приоритет
print(obj.non_data_attr) # NonDataDescriptor: __get__
obj.__dict__['non_data_attr'] = 'value in instance dict'
print(obj.non_data_attr) # value in instance dict (перекрыли дескриптор!)
```

---

### Практическое применение дескрипторов

1.  **Валидация данных (самое классическое применение):**
    Создание переиспользуемых атрибутов с проверкой. Вместо того чтобы писать сеттеры для каждого свойства, можно создать дескриптор.

    ```python
    class ValidatedString:
        def __init__(self, min_length=0, max_length=100):
            self.min_length = min_length
            self.max_length = max_length

        def __set_name__(self, owner, name):
            self.private_name = '_' + name # Сохраняем имя для хранения значения

        def __get__(self, instance, owner):
            return getattr(instance, self.private_name, None)

        def __set__(self, instance, value):
            if not isinstance(value, str):
                raise TypeError("Value must be a string.")
            if not (self.min_length <= len(value) <= self.max_length):
                raise ValueError(f"Value length must be between {self.min_length} and {self.max_length}.")
            setattr(instance, self.private_name, value)

    class UserProfile:
        username = ValidatedString(3, 20)
        bio = ValidatedString(0, 1000)

        def __init__(self, username, bio):
            self.username = username # Вызовет __set__ дескриптора
            self.bio = bio

    # user = UserProfile('ab', '...') # Вызовет ValueError: length must be between 3 and 20.
    user = UserProfile('valid_user', '...')
    print(user.username) # 'valid_user'
    ```

2.  **Ленивые вычисления (Lazy Evaluation):**
    Вычисление значения атрибута только при первом обращении к нему и кэширование результата.

    ```python
    class LazyProperty:
        def __init__(self, method):
            self.method = method
            self.cache_name = f"_lazy_{method.__name__}"

        def __get__(self, instance, owner):
            if instance is None:
                return self
            if not hasattr(instance, self.cache_name):
                value = self.method(instance)
                setattr(instance, self.cache_name, value)
            return getattr(instance, self.cache_name)

    class ExpensiveCalculations:
        @LazyProperty
        def heavy_calculation(self):
            print("Performing a very heavy calculation...")
            # Имитация долгой работы
            return sum(i * i for i in range(10_000_000))

    obj = ExpensiveCalculations()
    print(obj.heavy_calculation) # Первый вызов: печатает и считает
    print(obj.heavy_calculation) # Второй вызов: сразу возвращает результат
    ```

3.  **Создание переиспользуемых `@property`:** Дескрипторы позволяют инкапсулировать логику геттеров/сеттеров в отдельный класс, избегая дублирования кода, которое неизбежно при использовании множества однотипных `@property`.

---

### Связь с `@property`, `@classmethod`, `@staticmethod`

**Это ключевой момент для понимания.** Эти декораторы — не магия языка, а просто удобный синтаксический сахар для встроенных дескрипторов.

*   **`@property`** — это встроенный **data-дескриптор**.
    Код ниже примерно эквивалентен:
    ```python
    class MyClass:
        @property
        def x(self):
            return self._x

        # Эквивалентно:
        # def get_x(self): return self._x
        # x = property(get_x)
    ```

*   **`@classmethod`** и **`@staticmethod`** — это встроенные **non-data дескрипторы**.
    Они реализованы так, что их `__get__` возвращает соответствующий bound или unbound метод.

**Вывод для сеньора:** Дескрипторы — это не абстрактная теория, а фундаментальный механизм, на котором построены многие популярные инструменты Python. Понимание их работы позволяет не только создавать более мощные и элегантные абстракции (как в примере с валидацией), но и глубоко отлаживать проблемы, связанные с атрибутами и методами, понимая, что на самом деле происходит при вызове `obj.attr`.