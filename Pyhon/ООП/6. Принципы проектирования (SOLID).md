### 6. Принципы проектирования (SOLID)

Обсуждение SOLID — верный признак собеседования на сеньора.

* **S:** Single Responsibility (Принцип единственной ответственности). Как он помогает в тестировании и поддержке.
* **O:** Open/Closed (Принцип открытости/закрытости). Как достигается через абстракции (ABC) и композицию.
* **L:** Liskov Substitution (Принцип подстановки Лисков). Классический пример с квадратом и прямоугольником. Почему нарушение LSP ведет к хрупкому коду.
* **I:** Interface Segregation (Принцип разделения интерфейсов). Создание узкоспециализированных ABC вместо "божественных" интерфейсов.
* **D:** Dependency Inversion (Принцип инверсии зависимостей). Модули высокого уровня не должны зависеть от модулей низкого уровня. И те, и другие должны зависеть от абстракций.


Отлично! SOLID — это фундамент, на котором строится дизайн любого долгоживущего и поддерживаемого приложения. Обсуждение этих принципов показывает, что вы думаете не только о том, *как* написать код, но и о том, *почему* его нужно писать именно так.

Давайте разберем каждый принцип с акцентом на Python и практическую пользу.

---

### **S: Single Responsibility (Принцип единственной ответственности)**

**Формулировка:** Один класс должен иметь одну и только одну причину для изменения (то есть отвечать за одну часть функциональности).

**Python пример:**

```python
# НАРУШЕНИЕ SRP: Класс делает слишком много.
class UserManager:
    def __init__(self, user):
        self.user = user

    def change_user_name(self, new_name):
        # Ответственность: управление данными пользователя
        self.user.name = new_name

    def save_user_to_database(self):
        # Ответственность: работа с базой данных
        with database_connection() as db:
            db.execute('UPDATE users SET name = ? WHERE id = ?', (self.user.name, self.user.id))

    def send_welcome_email(self):
        # Ответственность: отправка email
        smtp_server.sendmail(...)

# СООТВЕТСТВИЕ SRP: Разделяем ответственность.
class User:
    def __init__(self, name, id_):
        self.name = name
        self.id = id_

class UserRepository:
    def save(self, user: User):
        with database_connection() as db:
            db.execute('UPDATE users SET name = ? WHERE id = ?', (user.name, user.id))

class EmailService:
    def send_welcome_email(self, user: User):
        smtp_server.sendmail(...)

# Теперь каждый класс меняется по своей, единственной причине.
user = User("John", 1)
user_repo = UserRepository()
email_service = EmailService()

user.name = "Jane"
user_repo.save(user)
email_service.send_welcome_email(user)
```

**Как это помогает:**
*   **Тестирование:** Проще написать unit-тесты. Вы можете протестировать `UserRepository` с mock-объектом базы данных, а `EmailService` — с mock-объектом SMTP, не поднимая реальные сервисы.
*   **Поддержка:** Если изменится способ отправки email (например, перейдем на новый API), мы будем править только `EmailService`. Это изменение не затронет логику сохранения пользователя или его данные.
*   **Поиск ошибок:** Если падает отправка email, мы сразу знаем, где искать проблему — в `EmailService`.

---

### **O: Open/Closed (Принцип открытости/закрытости)**

**Формулировка:** Классы должны быть открыты для расширения, но закрыты для модификации.

**Python пример (с использованием ABC):**

```python
from abc import ABC, abstractmethod

# НАРУШЕНИЕ OCP: Добавление нового типа требует изменения функции.
def calculate_area(shapes):
    total_area = 0
    for shape in shapes:
        if isinstance(shape, Rectangle):
            total_area += shape.width * shape.height
        elif isinstance(shape, Circle):
            total_area += shape.radius * shape.radius * 3.14
        # Чтобы добавить Triangle, придется МОДИФИЦИРОВАТЬ этот код!
    return total_area

# СООТВЕТСТВИЕ OCP: Код закрыт для модификации, но открыт для расширения.
class Shape(ABC):
    @abstractmethod
    def area(self) -> float:
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        return self.radius ** 2 * 3.14

def calculate_area(shapes: list[Shape]) -> float: # Функция теперь не зависит от конкретных типов
    total_area = 0
    for shape in shapes:
        total_area += shape.area() # Вызываем абстрактный метод
    return total_area

# Чтобы добавить Triangle, мы РАСШИРЯЕМ код, а не меняем существующий.
class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height
    def area(self):
        return 0.5 * self.base * self.height

# calculate_area теперь автоматически будет работать с Triangle!
shapes = [Rectangle(2, 3), Circle(5), Triangle(4, 6)]
print(calculate_area(shapes))
```

**Как это помогает:** Система становится стабильнее. Вы добавляете новую функциональность, создавая новые классы, а не переписывая существующий, уже протестированный и работающий код. Это резко снижает риск появления новых багов.

---

### **L: Liskov Substitution (Принцип подстановки Лисков)**

**Формулировка:** Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.

**Классический пример с прямоугольником и квадратом:**

```python
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height

    @property
    def width(self):
        return self._width

    @width.setter
    def width(self, value):
        self._width = value

    @property
    def height(self):
        return self._height

    @height.setter
    def height(self, value):
        self._height = value

    @property
    def area(self):
        return self._width * self._height

# Квадрат "is-a" прямоугольник? С точки зрения математики — да.
# Но с точки зрения поведения — нет.
class Square(Rectangle):
    def __init__(self, size):
        super().__init__(size, size)

    @Rectangle.width.setter
    def width(self, value):
        self._width = value
        self._height = value # Нарушает инварианты родителя!

    @Rectangle.height.setter
    def height(self, value):
        self._height = value
        self._width = value  # Нарушает инварианты родителя!

# Функция, работающая с базовым классом
def use_rectangle(rect: Rectangle):
    initial_area = rect.area
    rect.width = 10 # Ожидается, что изменится только ширина
    expected_area = initial_area * 10 / rect.width # ... расчеты
    # Но для Square меняется и высота! Расчеты становятся неверными.
    print(f"Expected area: {expected_area}, got: {rect.area}")

rectangle = Rectangle(5, 4)
use_rectangle(rectangle) # Работает корректно.

square = Square(5)
use_rectangle(square)    # Нарушение LSP! Поведение изменилось, программа работает неверно.
```

**Почему нарушение ведет к хрупкому коду:** Код, рассчитанный на работу с базовым классом (`Rectangle`), начинает ломаться при работе с подклассом (`Square`). Это приводит к тонким и сложноуловимым ошибкам, так как формально тип корректен (Square наследуется от Rectangle), но поведение — нет. Нарушение LSP заставляет проверять типы через `isinstance`, что является верным признаком проблемы с дизайном и нарушает OCP.

---

### **I: Interface Segregation (Принцип разделения интерфейсов)**

**Формулировка:** Клиенты не должны зависеть от методов, которые они не используют. Создавайте узкие, специфические интерфейсы вместо одного общего.

**Python пример:**

```python
# "Божественный" интерфейс
class MultiFunctionPrinter(ABC):
    @abstractmethod
    def print(self, document): pass
    @abstractmethod
    def scan(self, document): pass
    @abstractmethod
    def fax(self, document): pass

# Старой модели принтера приходятся реализовывать ненужные методы
class OldPrinter(MultiFunctionPrinter):
    def print(self, document):
        # OK
        print("Printing...")

    def scan(self, document):
        # Не поддерживается!
        raise NotImplementedError("Scan not supported")

    def fax(self, document):
        # Не поддерживается!
        raise NotImplementedError("Fax not supported")

# СООТВЕТСТВИЕ ISP: Дробим интерфейс
class Printer(ABC):
    @abstractmethod
    def print(self, document): pass

class Scanner(ABC):
    @abstractmethod
    def scan(self, document): pass

class Fax(ABC):
    @abstractmethod
    def fax(self, document): pass

# Теперь классы реализуют только то, что им нужно
class OldPrinter(Printer):
    def print(self, document):
        print("Printing...")

class ModernPrinter(Printer, Scanner, Fax):
    def print(self, document): ...
    def scan(self, document): ...
    def fax(self, document): ...
```

**Как это помогает:** Избавляет клиентов от зависимости от неиспользуемых методов и предотвращает появление "пустых" реализаций или исключений `NotImplementedError`. Код становится более явным и понятным.

---

### **D: Dependency Inversion (Принцип инверсии зависимостей)**

**Формулировка:**
1.  Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций.
2.  Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

**Python пример:**

```python
# НАРУШЕНИЕ DIP: Модуль высокого уровня зависит от модуля низкого уровня.
class LightBulb:
    def turn_on(self):
        print("LightBulb: turned on...")

    def turn_off(self):
        print("LightBulb: turned off...")

class ElectricPowerSwitch:
    def __init__(self, l: LightBulb): # Жесткая зависимость от конкретного класса LightBulb
        self.lightbulb = l
        self.on = False

    def press(self):
        if self.on:
            self.lightbulb.turn_off()
            self.on = False
        else:
            self.lightbulb.turn_on()
            self.on = True

# СООТВЕТСТВИЕ DIP: Оба модуля зависят от абстракции.
class Switchable(ABC):
    @abstractmethod
    def turn_on(self): pass
    @abstractmethod
    def turn_off(self): pass

class LightBulb(Switchable): # Деталь (низкий уровень) зависит от абстракции
    def turn_on(self):
        print("LightBulb: turned on...")
    def turn_off(self):
        print("LightBulb: turned off...")

class Fan(Switchable): # Теперь мы можем легко добавить новый устройство
    def turn_on(self):
        print("Fan: turned on...")
    def turn_off(self):
        print("Fan: turned off...")

class ElectricPowerSwitch:
    def __init__(self, device: Switchable): # Высокий уровень зависит от абстракции Switchable
        self.device = device
        self.on = False

    def press(self):
        if self.on:
            self.device.turn_off()
            self.on = False
        else:
            self.device.turn_on()
            self.on = True

# Использование
bulb = LightBulb()
switch = ElectricPowerSwitch(bulb)
switch.press()

fan = Fan()
switch_for_fan = ElectricPowerSwitch(fan) # Переключатель работает с любым Switchable
switch_for_fan.press()
```

**Как это помогает:** Это краеугольный камень гибкой архитектуры. Система становится слабосвязанной. Вы можете легко заменять и добавлять новые реализации (детали), не трогая код модулей высокого уровня. Этот принцип напрямую ведет к внедрению зависимостей (DI), который является главным механизмом его соблюдения.

**Итог:** SOLID — это не догма, а руководство к созданию понятного, гибкого и тестируемого кода. На собеседовании важно не просто пересказать принципы, а показать, как вы применяете их на практике для решения реальных проблем.