# Основы Python
<details>

<summary>Вопрос 1. Какие типы данных существуют в Python? Чем они отличаются друг от друга?</summary>

Типы данных делаться на изменяемые и неизменяемые.
Изменяемые: 

- list([]) - упорядоченные, 
- set( {} ), dict( {} ) - неупорядоченные
- bytearray: изменяемая версия bytes, но сами по себе объекты bytearray являются изменяемыми, так что это исключение.
Неизменяемые

- int: целые числа
- float: числа с плавающей запятой
- complex: комплексные числа
- bool: логические значения True или False.
- str: строки, например, "Hello", "Python".
- tuple: кортежи, например, (1, 2, 3). В случае если внутренне tuple неизменяемые типы данных
- bytes: последовательность байтов, например, b'hello'.
- frozenset: неизменяемая версия множества set.

Упорядоченность определяет, имеют ли элементы в объекте определенный порядок. 
 Списков (list), строк (str) и кортежей (tuple)
 (Словари dict): начиная с Python 3.7, словари гарантированно сохраняют порядок добавления элементов.

Неупорядоченные типы данных не гарантируют порядок элементов.

К ним, помимо множеств (set), относится и frozenset - неизменяемая версия множества.


</details>

<details>





<summary>Как реализован словарь в Python? (требуется объяснить его строение на более глубоком уровне)</summary>

В Python словарь реализован как хеш-таблица, что позволяет обеспечивать быстрый доступ к данным. Давайте рассмотрим его строение на более глубоком уровне:

1. **Хеш-таблица**: Словарь в Python использует хеш-таблицу для хранения данных. Хеш-таблица — это структура данных, которая отображает ключи на значения с использованием хеш-функции.

2. **Хеш-функция**: Для каждого ключа в словаре Python вычисляет хеш с помощью хеш-функции. Хеш-функция преобразует ключ в целое число, которое используется для определения индекса в массиве, где будет храниться значение.

3. **Массив и списки**: Хеш-таблица в Python состоит из массива, где каждый элемент массива является указателем на список. Каждый элемент этого списка хранит пару ключ-значение.

4. **Коллизии**: Если два ключа имеют одинаковый хеш (коллизия), они будут помещены в один и тот же список. Python использует метод разрешения коллизий, называемый "открытой адресацией" или "метод цепочек". В случае коллизии, элементы хранятся в виде списка (или другого контейнера) в одной ячейке массива.

5. **Динамическое изменение размера**: Python автоматически изменяет размер хеш-таблицы, если она становится слишком заполненной. Это делается для поддержания эффективности операций добавления, удаления и поиска.

6. **Порядок элементов**: Начиная с версии Python 3.7, порядок элементов в словаре сохраняется в порядке их добавления. Это реализовано с помощью дополнительного массива, который хранит порядок вставки ключей.

Вот пример простого словаря в Python:

```python
my_dict = {'key1': 'value1', 'key2': 'value2'}
```

В этом примере `'key1'` и `'key2'` — это ключи, а `'value1'` и `'value2'` — соответствующие значения. Когда вы обращаетесь к значению по ключу, Python использует хеш-функцию для быстрого нахождения нужного элемента в массиве.

Таким образом, словарь в Python обеспечивает быстрый доступ к данным благодаря использованию хеш-таблицы и эффективному управлению коллизиями.

</details>

<details>

<summary>"открытой адресацией" ИЛИ "метод цепочек" расскажи подробее </summary>

В контексте хеш-таблиц, таких как реализация словарей в Python, существуют два основных метода разрешения коллизий: метод цепочек и открытая адресация. Давайте рассмотрим каждый из них подробнее.

### Метод цепочек (Chaining)

Метод цепочек — это наиболее распространенный способ разрешения коллизий в хеш-таблицах. Основная идея заключается в том, что каждый элемент массива хеш-таблицы содержит указатель на список (или другую структуру данных), который хранит все пары ключ-значение, хеши которых соответствуют данному индексу.

**Преимущества:**

- Простота реализации.
- Хорошая производительность в среднем случае.

**Недостатки:**

- В худшем случае, когда все ключи имеют одинаковый хеш, производительность может снизиться до O(n) для операций поиска, вставки и удаления.
**Как это работает:**

1. **Хеширование**: Когда вы добавляете пару ключ-значение в хеш-таблицу, ключ хешируется для получения индекса в массиве.
2. **Добавление в список**: Если два ключа имеют одинаковый хеш (коллизия), они добавляются в один и тот же список, связанный с этим индексом.
3. **Поиск**: При поиске значения по ключу, ключ хешируется, чтобы найти соответствующий индекс в массиве. Затем выполняется поиск по списку, связанному с этим индексом, чтобы найти нужную пару ключ-значение.

**Преимущества:**

- Простота реализации.
- Хорошая производительность в среднем случае.

**Недостатки:**

- В худшем случае, когда все ключи имеют одинаковый хеш, производительность может снизиться до O(n) для операций поиска, вставки и удаления.

### Открытая адресация (Open Addressing)

Открытая адресация — это альтернативный метод разрешения коллизий, при котором все элементы хранятся непосредственно в массиве хеш-таблицы. Если происходит коллизия, алгоритм ищет следующую доступную ячейку в массиве.

**Как это работает:**

1. **Хеширование**: Ключ хешируется для получения индекса в массиве.
2. **Поиск доступной ячейки**: Если ячейка с полученным индексом уже занята, алгоритм ищет следующую доступную ячейку. Это может быть сделано с помощью различных стратегий, таких как линейное зондирование, квадратичное зондирование или двойное хеширование.
3. **Вставка**: Пара ключ-значение вставляется в первую найденную доступную ячейку.

**Преимущества:**

- Более эффективное использование памяти, так как не требуется хранить дополнительные структуры данных, такие как списки.
- Хорошая производительность в случае хорошего распределения хешей.

**Недостатки:**

- Более сложная реализация по сравнению с методом цепочек.
- Производительность может снижаться, если таблица становится слишком заполненной, так как требуется больше времени на поиск доступных ячеек.

Оба метода имеют свои преимущества и недостатки, и выбор между ними зависит от конкретных требований и условий использования. В Python используется метод цепочек для разрешения коллизий в словарях.

______________________________________
Метод цепочек — это способ разрешения коллизий в хеш-таблицах. Вот как он работает кратко:

Хеширование: Ключ преобразуется в хеш, который определяет индекс в массиве.
Связанные списки: Каждый элемент массива указывает на связанный список, который хранит пары ключ-значение.
Разрешение коллизий: Если два ключа имеют одинаковый хеш, они добавляются в один и тот же связанный список.
Поиск: При поиске значения по ключу, сначала вычисляется хеш ключа, чтобы найти индекс в массиве, а затем выполняется поиск по связанному списку для нахождения нужного значения.

Таким образом, метод цепочек позволяет эффективно управлять коллизиями, сохраняя все элементы с одинаковым хешем в одном списке.

</details>

<details>
<summary> Когда возникают коллизии и какие методы их обработок существуют? Что используется в python?</summary>


Коллизии в хеш-таблицах возникают, когда два разных входных значения имеют один и тот же хеш, то есть когда два разных ключа отображаются в один и тот же индекс в массиве. Это может привести к проблемам, так как данные могут быть перезаписаны или потеряны, если не обрабатывать такие ситуации должным образом.

Вот несколько распространенных методов обработки коллизий:

1. **Метод цепочек (Chaining):** Каждый элемент хеш-таблицы является указателем на список (или другую структуру данных), содержащий все элементы, хешируемые в данный индекс. При коллизии новый элемент просто добавляется в этот список.

2. **Открытая адресация (Open Addressing):** При возникновении коллизии, алгоритм ищет следующее доступное место в массиве. Существует несколько подходов к открытой адресации:
   - Линейное исследование: проверка следующего индекса до нахождения свободного места.
   - Квадратичное исследование: проверка следующего индекса с квадратичным шагом.
   - Двойное хеширование: использование второго хеш-функции для определения шага поиска.

В Python для обработки коллизий в хеш-таблицах используется метод цепочек. Встроенные типы данных, такие как словари (`dict`), используют хеш-таблицы для хранения данных, и Python автоматически обрабатывает коллизии с помощью метода цепочек. Это позволяет эффективно управлять данными и обеспечивает быстрый доступ к элементам.
</details>


<details>
<summary> Вопрос 4. Когда возникают коллизии и какие методы их обработок существуют? Что используется в python?</summary>


Коллизии в хеш-таблицах возникают, когда два разных входных значения имеют один и тот же хеш, то есть когда два разных ключа отображаются в один и тот же индекс в массиве. Это может привести к проблемам, так как данные могут быть перезаписаны или потеряны, если не обрабатывать такие ситуации должным образом.


Метод цепочек (Chaining) и Открытая адресация. В python используется Метод цепочек

Метод цепочек (Chaining) - каждый элемент массива хеш-таблицы содержит указатель на список (или другой тип данных), который хранит все пары ключ значений, хешей которые соответствуют данном индексу.

Плюс проста реализация и Хорошая производительность в среднем случае.

В худшем случае, когда все ключи имеют одинаковый хеш, производительность может снизиться до O(n) для операций поиска, вставки и удаления.

Когда вы добавляете пару ключ-значение в хеш-таблицу, ключ хешируется для получения индекса в массиве.
Если два ключа имеют одинаковый хеш (коллизия), они добавляются в один и тот же список, связанный с этим индексом.
При поиске значения по ключу, ключ хешируется, чтобы найти соответствующий индекс в массиве. Затем выполняется поиск по списку, связанному с этим индексом, чтобы найти нужную пару ключ-значение.

Открытая адресация — это альтернативный метод разрешения коллизий, при котором все элементы хранятся непосредственно в массиве хеш-таблицы. Если происходит коллизия, алгоритм ищет следующую доступную ячейку в массиве.

Ключ хешируется для получения индекса в массиве.
Если ячейка с полученным индексом уже занята, алгоритм ищет следующую доступную ячейку. Это может быть сделано с помощью различных стратегий, таких как линейное зондирование, квадратичное зондирование или двойное хеширование.

Пара ключ-значение вставляется в первую найденную доступную ячейку.

Преимущества: Более эффективное использование памяти, так как не требуется хранить дополнительные структуры данных, такие как списки. Хорошая производительность в случае хорошего распределения хешей.

Недостатки: Более сложная реализация по сравнению с методом цепочек. Производительность может снижаться, если таблица становится слишком заполненной, так как требуется больше времени на поиск доступных ячеек.

</details>

<details>
<summary>Какие объекты могут являться ключами в словарях? Желательно максимально подробно с разными примерами</summary>

Ключи в словарях Python должны быть **хешируемыми** (hashable). Это единственное жёсткое требование.  
Хешируемый объект — это объект, у которого:

1. Определён метод `__hash__()`, возвращающий целое число, и это число **не меняется** за всё время жизни объекта.
2. Определён метод `__eq__()` для сравнения на равенство.
3. Если `a == b`, то `hash(a) == hash(b)`.

Если объект изменяемый (его содержимое можно изменить после создания), он **не может быть хешируемым** и, значит, не может быть ключом. Примеры **нельзя** использовать как ключи: `list`, `dict`, `set`, `bytearray`, большинство пользовательских классов по умолчанию (если не сделаны ими хешируемыми).

---

### ✅ Что **можно** использовать как ключи

#### 1. **Неизменяемые встроенные типы**
```python
d = {
    42: "число",
    3.14: "пи",
    "hello": "строка",
    True: "булево",
    None: "None",
    (1, 2): "кортеж",
    frozenset({1, 2, 3}): "frozenset",
    b"bytes": "байты",
    (1, "a", (2, 3)): "вложенный кортеж"
}
```

#### 2. **Классы-перечисления (Enum)**
```python
from enum import Enum

class Color(Enum):
    RED = 1
    GREEN = 2

d = {Color.RED: "красный", Color.GREEN: "зелёный"}
```

#### 3. **Пользовательские классы** (если они неизменяемые или переопределены `__hash__` и `__eq__`)
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return isinstance(other, Point) and (self.x, self.y) == (other.x, other.y)

    def __hash__(self):
        return hash((self.x, self.y))

d = {Point(1, 2): "точка"}
```

#### 4. **Именованные кортежи (`namedtuple`)**
```python
from collections import namedtuple

Person = namedtuple("Person", ["name", "age"])
d = {Person("Alice", 30): "инженер"}
```

#### 5. **Датаклассы с `frozen=True`**
```python
from dataclasses import dataclass

@dataclass(frozen=True)
class Product:
    name: str
    price: float

d = {Product("Молоко", 1.99): "молочный отдел"}
```

#### 6. **Специальные типы из стандартной библиотеки**
```python
import datetime
import ipaddress

d = {
    datetime.date(2025, 7, 30): "сегодня",
    ipaddress.IPv4Address("192.168.1.1"): "роутер"
}
```

---

### ❌ Что **нельзя** использовать как ключи

```python
bad_keys = [
    [1, 2, 3],          # list — изменяемый
    {"a": 1},           # dict — изменяемый
    {1, 2, 3},          # set — изменяемый
    bytearray(b"abc"),  # bytearray — изменяемый
]
```

Попытка использовать их вызовет `TypeError: unhashable type: 'list'`.

---

### 🧪 Проверка хешируемости
```python
def is_hashable(obj):
    try:
        hash(obj)
        return True
    except TypeError:
        return False

print(is_hashable((1, 2)))     # True
print(is_hashable([1, 2]))     # False
```

---

### 🧵 Подводные камни

- **Кортежи** могут быть ключами, **если все их элементы хешируемы**:
  ```python
  {(1, [2, 3]): "ошибка"}  # TypeError: unhashable type: 'list'
  ```

- **Булевы значения** `True` и `False** эквивалентны `1` и `0` при сравнении:
  ```python
  d = {True: "истина", 1: "единица"}
  print(d)  # {True: "единица"} — 1 перезаписал True
  ```

- **None** и **Ellipsis** (`...`) тоже хешируемы:
  ```python
  d = {None: "ничто", ...: "многоточие"}
  ```

---

### 📌 Итого
**Правило:** ключом может быть **любой объект**, у которого:
- `hash(obj)` не выбрасывает `TypeError`
- `obj` неизменяем (или изменяем, но хеш всегда одинаковый и `__eq__` реализован корректно)

Если сомневаетесь — проверяйте `hash(obj)` или `is_hashable(obj)`.

</details>

<details>
<summary>Создайте декоратор timer_decorator для подсчета времени работы функции и дополнительно ответь на вопрос "как создать декоратор с параметрами?</summary>

# Создайте декоратор timer_decorator для подсчета времени работы функции и дополнительно ответь на вопрос "как создать декоратор с параметрами?"

```python
import time

def timer_decorator(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        print(f'Время выполнения функции - {time.time() - start} сек')
        return result
    return wrapper


# Пример использования декоратора 
@timer_decorator 
def example_function(numbers): 
    _ = [number for number in range(1, numbers + 1) if number % 2 == 0] 
    return 'Готово' 

# Вызов функции для теста 
result = example_function(10_000_000) 
print(result) 
```

Декораторы в Python - это своего рода "обёртка" для функций, позволяющая добавлять им новую функциональность без изменения их исходного кода. Представьте, что вам нужно украсить торт: вы не будете менять сам рецепт торта, а просто добавите сверху украшения. Так же и декораторы - они "украшают" функцию дополнительными действиями.

Декоратор - это функция, которая оборачивает другую функцию для изменения ее функциональности без изменения самого кода

Общее правило - декоратор принимает функцию в качестве аргумента и возвращает функцию.

Как передать параметры в декоратор?

Для этого нам понадобится еще один уровень вложенности функций. Внешняя функция будет принимать параметры декоратора, а внутренняя - саму декорируемую функцию.

```python
def repeat(num_times):
    def decorator_repeat(func):
        def wrapper(*args, **kwargs):
            for _ in range(num_times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator_repeat

@repeat(num_times=3)
def greet(name):
    print(f"Привет, {name}!")

greet("Алиса")
```

</details>


<details>
<summary>Как работает система управления памятью в Python?</summary>

В Python система управления памятью автоматически обрабатывает выделение и освобождение памяти для объектов. Вот основные механизмы, которые она использует:

### 1. **Менеджер памяти**
Python использует менеджер памяти для эффективного управления выделением и освобождением памяти. Он отвечает за выделение и освобождение блоков памяти для объектов, которые создаются и удаляются в программе.

### 2. **Сборщик мусора**
Python имеет встроенный сборщик мусора, который автоматически удаляет объекты, на которые больше нет ссылок. Это предотвращает утечки памяти и освобождает ресурсы, которые больше не используются.

#### **Счетчик ссылок**
Основной механизм сбора мусора в Python — это счетчик ссылок. Каждый объект имеет счетчик ссылок, который увеличивается, когда на объект создается новая ссылка, и уменьшается, когда ссылка удаляется. Когда счетчик ссылок достигает нуля, объект автоматически удаляется из памяти.

#### **Сборщик циклических ссылок**
Счетчик ссылок не может обработать ситуации с циклическими ссылками (когда объекты ссылаются друг на друга). Для этого Python использует дополнительный сборщик мусора, который периодически проверяет и удаляет циклические ссылки.

### 3. **Область видимости и время жизни объектов**
Время жизни объекта определяется его областью видимости. Например, локальные переменные существуют только в пределах функции, в которой они объявлены, и удаляются после выхода из функции. Глобальные переменные существуют на протяжении всего времени выполнения программы.

### 4. **Управление памятью на уровне интерпретатора**
Python-интерпретатор управляет памятью на низком уровне. Он использует различные стратегии для оптимизации выделения и освобождения памяти, например, кэширование свободных объектов для быстрого повторного использования.

### 5. **Модуль `gc`**
Python предоставляет модуль `gc`, который позволяет программистам управлять сборщиком мусора вручную. Например, можно включать и выключать сборщик мусора, а также вызывать его принудительно.

### Примеры
```python
import gc

# Создание объектов
a = [1, 2, 3]
b = a  # Создается ссылка на список

# Удаление ссылок
del a
del b

# Принудительный вызов сборщика мусора
gc.collect()
```
</details>

<details>
<summary>Что делают методы __iter__ и __next__ в итераторе?</summary>

Методы `__iter__` и `__next__` являются ключевыми для создания итераторов в Python. Они позволяют объектам поддерживать протокол итератора, который используется для последовательного доступа к элементам коллекции. Вот их основные функции:

### Метод `__iter__`
- **Цель**: Метод `__iter__` должен возвращать итератор. Обычно он возвращает сам объект, если он уже является итератором.
- **Использование**: Когда вы используете функцию `iter()` на объекте, Python вызывает метод `__iter__` этого объекта.
- **Пример**:
  ```python
  class MyIterator:
      def __init__(self, data):
          self.data = data
          self.index = 0

      def __iter__(self):
          return self  # Возвращает сам объект, так как он уже является итератором
  ```

### Метод `__next__`
- **Цель**: Метод `__next__` должен возвращать следующий элемент из коллекции. Если элементов больше нет, он должен вызвать исключение `StopIteration`.
- **Использование**: Когда вы используете функцию `next()` на итераторе, Python вызывает метод `__next__` этого итератора.
- **Пример**:
  ```python
  class MyIterator:
      def __init__(self, data):
          self.data = data
          self.index = 0

      def __iter__(self):
          return self

      def __next__(self):
          if self.index < len(self.data):
              result = self.data[self.index]
              self.index += 1
              return result
          else:
              raise StopIteration  # Вызывает исключение, когда элементы закончились
  ```

### Пример использования итератора
```python
my_data = [1, 2, 3, 4, 5]
my_iterator = MyIterator(my_data)

for item in my_iterator:
    print(item)
```

### Результат
```
1
2
3
4
5
```

### Встроенные итераторы
Встроенные типы данных в Python, такие как списки, кортежи, словари и множества, уже реализуют протокол итератора. Например:
```python
my_list = [1, 2, 3, 4, 5]
my_iterator = iter(my_list)

print(next(my_iterator))  # Выводит 1
print(next(my_iterator))  # Выводит 2
# и так далее
```

### Заключение
Методы `__iter__` и `__next__` позволяют создавать собственные итераторы, которые могут быть использованы в циклах `for` и других конструкциях, требующих итерации. Это делает код более гибким и позволяет работать с последовательностями данных эффективным образом.
</details>
<details>
<summary>Вопрос 10. Что такое замыкания?</summary>

Замыкания (closures) в Python — это функции, которые запоминают значения из своей окружающей области видимости, даже после того, как эта область видимости больше не существует. Это позволяет функции использовать переменные из внешней области, даже если вызов происходит в другом контексте.

### Пример

Вот простой пример замыкания:

```python
def outer_function(x):
    def inner_function(y):
        return x + y
    return inner_function

closure = outer_function(10)
print(closure(5))  # Вывод: 15
```

В этом примере:

1. `outer_function` принимает аргумент `x`.
2. Внутри `outer_function` определяется `inner_function`, которая использует переменную `x`.
3. `outer_function` возвращает `inner_function`.
4. Когда мы вызываем `outer_function(10)`, мы получаем функцию `inner_function`, которая запоминает значение `x = 10`.
5. `closure` — это замыкание, которое помнит значение `x = 10`. При вызове `closure(5)` мы получаем результат `10 + 5 = 15`.

### Зачем нужны замыкания?

Замыкания полезны в следующих случаях:

1. **Скрытие состояния**: Замыкания позволяют создавать функции, которые имеют доступ к внутреннему состоянию, но не разглашают его напрямую.
2. **Конфигурируемые функции**: Замыкания можно использовать для создания функций с предустановленными параметрами.
3. **Кэширование и оптимизация**: Замыкания могут использоваться для хранения промежуточных результатов вычислений, что может ускорить работу программы.

### Важные моменты

- Замыкания запоминают переменные, а не их значения. Если значение переменной изменяется, замыкание будет использовать новое значение.
- Замыкания работают только с неизменяемыми объектами (например, числами, строками). Если вам нужно изменить переменную, используйте мутабельные объекты (например, списки или словари) или другие способы.

Надеюсь, это объяснение помогло вам понять, что такое замыкания в Python!
</details>


# ООП

## Классы

Краткое описание

ООП реализовано через классы

Класс в Python — это как инструкция или чертеж для создания вещей
Объект — это конкретная вещь, сделанная по этой инструкции
Объектно-ориентированное программирование (ООП) — это использование таких инструкций для создания объектов и решения задач.

Классы в Python — это как шаблоны или чертежи для создания объектов. Они позволяют нам описывать, какие свойства (данные) и методы (действия) будут у объектов.

Представь себе коробку:

*Класс* — это описание того, какая коробка и что в неё можно класть.

*Объект* — это сама коробка с конкретными предметами внутри.

*Метод* - действия объектов.

Параметры (метода) - дополнительные данные, которые передаются извне, чтобы мы могли выполнять действия (их может не быть).

  

Простой пример:
Допустим, мы хотим создать программу для работы с "Машинами".

1. Создадим класс "Машина":

```
class Car:
    def __init__(self, brand_param, color_param):
        self.brand = brand_param
        self.color = color_param

    def drive(self):
        print(f"{self.color} {self.brand} едет!")
```

Что происходит:
Объявление класса
```
class Car:
```

Здесь мы создаём новый класс с именем Car.

Это значит, что мы определяем новый тип данных, который будет описывать машины.
Метод __init__
```
def __init__(self, brand_param, color_param):
    self.brand = brand_param
    self.color = color_param
```
    

__init__ — это специальный метод, называемый конструктором (лучше говорить "инициализатор"). Он автоматически вызывается, когда мы создаём новый объект класса Car.

   

Параметры:

*self* - это ссылка на сам объект (будем использовать, когда будем создавать объекты). Т.к. класс - это описание будущего объекта, то мы сразу закладываем логику для работы с самим объектом. Чаще всего он будет присутствовать у методов (но иногда его может не быть. Читай ниже)

*brand_param* - переменная внутри метода (в данном случае будет обозначать бренд)

*colour_param* - переменная внутри метода (в данном случае будет обозначать цвет)

   

 Логика внутри метода:

self.brand = brand_param присваиваем атрибут brand для нашего объекта (будущего, класс - это описание) и присваиваем ему значение brand_param

Т.е. теперь наш объект будет обладать параметром brand. brand_param - это переменная внутри __init__, к объекту не относится. 

self.color = color_param аналогично, создаём атрибут color и присваиваем ему значение параметра color_param.

Часто можно увидеть такое
```
def __init__(self, brand, color):
    self.brand = brand
    self.color = color
```
Важно не путать переменные (справа) и атрибуты объекта (слева)

    
```
Метод drive
def drive(self):

    print(f"{self.color} {self.brand} едет!")
```
  

Это обычный метод (просто функция), который мы можем вызывать на объектах Car.

Он не принимает дополнительных параметров (кроме self). Здесь нам self нужен как раз для того, чтобы обратиться к нашим атрибутам будущего объекта

  

  

2. Создадим объекты этого класса:
```
# Создаём две машины
car1 = Car("Toyota", "Красная")
car2 = Car("BMW", "Синяя")

# Вызываем метод drive для каждой машины
car1.drive()  # Выведет: Красная Toyota едет!
car2.drive()  # Выведет: Синяя BMW едет!
# Создаём две машины
car1 = Car("Toyota", "Красная")
car2 = Car("BMW", "Синяя")

# Вызываем метод drive для каждой машины
car1.drive()  # Выведет: Красная Toyota едет!
car2.drive()  # Выведет: Синяя BMW едет!
```

Что происходит:
- Мы создали класс Car, который описывает, какие данные и действия есть у машины (в п.1)
- Затем мы создали два объекта car1 и car2, каждый из которых является конкретной машиной со своими свойствами
- Вызвали метод drive, который выводит сообщение о том, что машина едет
  

Зачем это нужно:
- Модульность: Код делится на части (классы), что делает его организованным и понятным.
- Повторное использование: Наследование и объекты позволяют использовать код многократно.
- Инкапсуляция: Скрывает данные и защищает их от неправильного использования.
- Масштабируемость: Новые функции можно легко расширять и добавлять.
- Полиморфизм: Один интерфейс для работы с разными объектами.
- Лёгкость поддержки: Упрощает исправление и улучшение кода.
- Моделирование реального мира: Удобно описывать данные и действия (отражать логику реальных объектов).
  

ООП делает код более гибким, понятным и удобным для больших проектов.

     

   
Дополнительные материалы:


https://proglib.io/p/python-oop 
https://www.youtube.com/playlist?list=PLNi5HdK6QEmX9fxp3_IBFx1O5tiTmKlYm

### Наследование, Полиморфизм, Инкапсуляция, Абстракция

Вкратце о наследовании, полиморфизме, инкапсуляции и абстракции

**Наследование** — это механизм в объектно-ориентированном программировании, который позволяет одному классу (наследнику) получать свойства и методы другого класса (родителя), повторно используя код и упрощая его расширение.
  
**Полиморфизм** — это способность объектов разных классов реагировать на одинаковые методы по-своему, позволяя использовать единый интерфейс для работы с разными типами данных.
  
**Инкапсуляция** — это принцип сокрытия внутреннего состояния объекта и предоставления доступа к нему только через определенные методы, что защищает данные от прямого вмешательства и обеспечивает их целостность.
  
**Абстракция** — это процесс выделения значимых характеристик объекта и игнорирования несущественных деталей, что упрощает работу с комплексными системами за счет представления только необходимой информации.
 

После создания классов и объектов, важно углубиться в ключевые аспекты ООП

Наследование
Наследование – это механизм, при котором один класс (дочерний) наследует свойства и методы другого класса (родительского). Это позволяет переиспользовать код.

```python
# Родительский класс
class Animal:
    def make_sound(self):
        print("Some generic sound")


# Дочерний класс
class Dog(Animal):
    pass  # Не добавляем новых методов (пока)


# Использование
dog = Dog()
dog.make_sound()  # Вывод: Some generic sound
# Родительский класс
class Animal:
    def make_sound(self):
        print("Some generic sound")


# Дочерний класс
class Dog(Animal):
    pass  # Не добавляем новых методов (пока)


# Использование
dog = Dog()
dog.make_sound()  # Вывод: Some generic sound
```
Простой пример: собака (Dog) унаследовала действие make_sound() от класса Animal.

Полиморфизм
Полиморфизм — это возможность обработать объекты из разных классов одинаковым образом, вызывать одинаковые методы и переопределять сами методы

````python
class Cat:
    def make_sound(self):
        print("Meow")

class Dog:
    def make_sound(self):
        print("Woof")

# Использование
animals = [Cat(), Dog()] # Список животных


for animal in animals:
    animal.make_sound()

class Cat:
    def make_sound(self):
        print("Meow")

class Dog:
    def make_sound(self):
        print("Woof")

# Использование
animals = [Cat(), Dog()] # Список животных


for animal in animals:
    animal.make_sound()
````
Полиморфизм и наследование
Как и в других языках программирования, в Python дочерние классы могут наследовать методы и атрибуты родительского класса. Мы можем переопределить некоторые методы и атрибуты специально для того, чтобы они соответствовали дочернему классу, и это поведение нам известно как переопределение метода(method overriding).

Полиморфизм позволяет нам иметь доступ к этим переопределённым методам и атрибутам, которые имеют то же самое имя, что и в родительском классе.

````python
# Родительский класс
class Animal:
    def eat(self):
        print("Mmm, tasty")

    def make_sound(self):
        print("Some generic sound")


class Cat(Animal):
    def make_sound(self):
        print("Meow")


class Dog(Animal):
    def make_sound(self):
        print("Woof")


# Использование
cat = Cat()
cat.make_sound() # Вывод: Meow - переопределили для нашего класса
cat.eat() # Вывод: Mmm, tasty - использовали из класса-родителя

dog = Dog()
dog.make_sound()  # Вывод: Woof
# Родительский класс
class Animal:
    def eat(self):
        print("Mmm, tasty")

    def make_sound(self):
        print("Some generic sound")


class Cat(Animal):
    def make_sound(self):
        print("Meow")


class Dog(Animal):
    def make_sound(self):
        print("Woof")


# Использование
cat = Cat()
cat.make_sound() # Вывод: Meow - переопределили для нашего класса
cat.eat() # Вывод: Mmm, tasty - использовали из класса-родителя

dog = Dog()
dog.make_sound()  # Вывод: Woof
````

Инкапсуляция
Инкапсуляция — это защита "внутренностей" объекта. То есть объект сам управляет своими данными и не позволяет просто так их менять снаружи

Реализовано на уровне договоренностей через одно нижнее подчеркивание (_) и два нижних подчеркивания (__) в начале имени переменной или метода

````python
class Box:
    def __init__(self, item):
        self.__item = item  # Прячем содержимое (частная переменная)

    def put_item(self, item):
        self.__item = item  # Меняем игрушку

    def get_item(self):
        return self.__item  # Достаём игрушку


# Использование
box = Box("Мячик")
print(box.get_item())  # Вывод: Мячик

box.put_item("Кукла")
print(box.get_item())  # Вывод: Кукла

print(box.__item)  # ошибка
class Box:
    def __init__(self, item):
        self.__item = item  # Прячем содержимое (частная переменная)

    def put_item(self, item):
        self.__item = item  # Меняем игрушку

    def get_item(self):
        return self.__item  # Достаём игрушку


# Использование
box = Box("Мячик")
print(box.get_item())  # Вывод: Мячик

box.put_item("Кукла")
print(box.get_item())  # Вывод: Кукла

print(box.__item)  # ошибка
````
Инкапсуляция в Python работает немного иначе по сравнению с другими языками программирования. Вот основные моменты, которые нужно знать.

 

Нет жесткой приватности

В Python нет строгой защиты переменных, как, например, в Java. Даже если ты пометишь переменную как приватную (например, с двумя подчеркиваниями), к ней всё равно можно получить доступ.

````python
class Box:
    def __init__(self, item):
        self.__item = item  # Приватная переменная


box = Box("Мячик")
print(box._Box__item)  # Получаем доступ: Мячик
class Box:
    def __init__(self, item):
        self.__item = item  # Приватная переменная


box = Box("Мячик")
print(box._Box__item)  # Получаем доступ: Мячик
````

````python
class Box:
    def __init__(self, item):
        self._inner_item = item  # "Защищённое" содержимое

    def _protected_method(self):
        print("Это защищённый метод")


box = Box("Мячик")
print(box._inner_item)  # Доступ есть, но лучше не трогать
box._protected_method()  # Можно вызвать, но считается не очень хорошей практикой
class Box:
    def __init__(self, item):
        self._inner_item = item  # "Защищённое" содержимое

    def _protected_method(self):
        print("Это защищённый метод")


box = Box("Мячик")
print(box._inner_item)  # Доступ есть, но лучше не трогать
box._protected_method()  # Можно вызвать, но считается не очень хорошей практикой
````
Python позволяет нарушить любую инкапсуляцию. Однако это требует сознательного выбора в пользу удобства или отладки

  

Абстракция
Абстракция — это концепция, позволяющая скрыть детали реализации и представлять только основные аспекты объекта или процесса. В Python реализация абстракции сводится к созданию структур, которые задают интерфейс, оставляя конкретные детали реализации подклассам.

  

Python использует модуль abc (Abstract Base Classes) для создания абстрактных классов. Абстрактный класс — это такой класс, который задаёт интерфейс (набор методов), но не реализует их всех.

Для создания абстрактных классов используются:

ABC: базовый класс для абстрактных классов.
Декоратор @abstractmethod: для обозначения методов, которые обязательно должны быть реализованы в дочерних классах.
````python
from abc import ABC, abstractmethod


class Animal(ABC):  # Абстрактный класс
    @abstractmethod
    def make_sound(self):  # Абстрактный метод
        pass


class Dog(Animal):  # Класс-наследник
    def make_sound(self):
        return "Гав-гав!"


# cat = Animal()  # Ошибка: нельзя создать экземпляр абстрактного класса
dog = Dog()
print(dog.make_sound())  # Вывод: Гав-гав!
from abc import ABC, abstractmethod


class Animal(ABC):  # Абстрактный класс
    @abstractmethod
    def make_sound(self):  # Абстрактный метод
        pass


class Dog(Animal):  # Класс-наследник
    def make_sound(self):
        return "Гав-гав!"


# cat = Animal()  # Ошибка: нельзя создать экземпляр абстрактного класса
dog = Dog()
print(dog.make_sound())  # Вывод: Гав-гав!
````