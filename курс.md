
<details>

<summary>Вопрос 1. Какие типы данных существуют в Python? Чем они отличаются друг от друга?</summary>

Типы данных делаться на изменяемые и неизменяемые.
Изменяемые: 

- list([]) - упорядоченные, 
-  set( {} ), dict( {} )  - неупорядоченные
- bytearray: изменяемая версия bytes, но сами по себе объекты bytearray являются изменяемыми, так что это исключение.
Неизменяемые

- int: целые числа
- float: числа с плавающей запятой
- complex: комплексные числа
- bool: логические значения True или False.
- str: строки, например, "Hello", "Python".
- tuple: кортежи, например, (1, 2, 3). В случае если внутренне tuple неизменяемые типы данных
- bytes: последовательность байтов, например, b'hello'.
- frozenset: неизменяемая версия множества set.

Упорядоченность определяет, имеют ли элементы в объекте определенный порядок. 
 Списков (list), строк (str) и кортежей (tuple)
 (Словари dict): начиная с Python 3.7, словари гарантированно сохраняют порядок добавления элементов.

Неупорядоченные типы данных не гарантируют порядок элементов.

К ним, помимо множеств (set), относится и frozenset - неизменяемая версия множества.


</details>

<details>

<summary>Как реализован словарь в Python? (требуется объяснить его строение на более глубоком уровне)</summary>

В Python словарь реализован как хеш-таблица, что позволяет обеспечивать быстрый доступ к данным.
Словарь в Python использует хеш-таблицу для хранения данных. Хеш-таблица — это структура данных, которая отображает ключи на значения с использованием хеш-функции. Для каждого ключа в словаре Python вычисляет хеш с помощью хеш-функции. Хеш-функция преобразует ключ в целое число, которое используется для определения индекса в массиве, где будет храниться значение.

Хеш-таблица в Python состоит из массива, где каждый элемент массива является указателем на список. Каждый элемент этого списка хранит пару ключ-значение.

Коллизии

Если два ключа имеют одинаковый хеш (коллизия), они будут помещены в один и тот же список. Python использует метод разрешения коллизий, называемый "открытой адресацией" или "метод цепочек". В случае коллизии, элементы хранятся в виде списка (или другого контейнера) в одной ячейке массива.

Динамическое изменение размера

Python автоматически изменяет размер хеш-таблицы, если она становится слишком заполненной. Это делается для поддержания эффективности операций добавления, удаления и поиска.

</details>




<summary>Как реализован словарь в Python? (требуется объяснить его строение на более глубоком уровне)</summary>

В Python словарь реализован как хеш-таблица, что позволяет обеспечивать быстрый доступ к данным. Давайте рассмотрим его строение на более глубоком уровне:

1. **Хеш-таблица**: Словарь в Python использует хеш-таблицу для хранения данных. Хеш-таблица — это структура данных, которая отображает ключи на значения с использованием хеш-функции.

2. **Хеш-функция**: Для каждого ключа в словаре Python вычисляет хеш с помощью хеш-функции. Хеш-функция преобразует ключ в целое число, которое используется для определения индекса в массиве, где будет храниться значение.

3. **Массив и списки**: Хеш-таблица в Python состоит из массива, где каждый элемент массива является указателем на список. Каждый элемент этого списка хранит пару ключ-значение.

4. **Коллизии**: Если два ключа имеют одинаковый хеш (коллизия), они будут помещены в один и тот же список. Python использует метод разрешения коллизий, называемый "открытой адресацией" или "метод цепочек". В случае коллизии, элементы хранятся в виде списка (или другого контейнера) в одной ячейке массива.

5. **Динамическое изменение размера**: Python автоматически изменяет размер хеш-таблицы, если она становится слишком заполненной. Это делается для поддержания эффективности операций добавления, удаления и поиска.

6. **Порядок элементов**: Начиная с версии Python 3.7, порядок элементов в словаре сохраняется в порядке их добавления. Это реализовано с помощью дополнительного массива, который хранит порядок вставки ключей.

Вот пример простого словаря в Python:

```python
my_dict = {'key1': 'value1', 'key2': 'value2'}
```

В этом примере `'key1'` и `'key2'` — это ключи, а `'value1'` и `'value2'` — соответствующие значения. Когда вы обращаетесь к значению по ключу, Python использует хеш-функцию для быстрого нахождения нужного элемента в массиве.

Таким образом, словарь в Python обеспечивает быстрый доступ к данным благодаря использованию хеш-таблицы и эффективному управлению коллизиями.

</details>

<details>

<summary>"открытой адресацией" ИЛИ "метод цепочек" расскажи подробее </summary>

В контексте хеш-таблиц, таких как реализация словарей в Python, существуют два основных метода разрешения коллизий: метод цепочек и открытая адресация. Давайте рассмотрим каждый из них подробнее.

### Метод цепочек (Chaining)

Метод цепочек — это наиболее распространенный способ разрешения коллизий в хеш-таблицах. Основная идея заключается в том, что каждый элемент массива хеш-таблицы содержит указатель на список (или другую структуру данных), который хранит все пары ключ-значение, хеши которых соответствуют данному индексу.

**Преимущества:**

- Простота реализации.
- Хорошая производительность в среднем случае.

**Недостатки:**

- В худшем случае, когда все ключи имеют одинаковый хеш, производительность может снизиться до O(n) для операций поиска, вставки и удаления.
**Как это работает:**

1. **Хеширование**: Когда вы добавляете пару ключ-значение в хеш-таблицу, ключ хешируется для получения индекса в массиве.
2. **Добавление в список**: Если два ключа имеют одинаковый хеш (коллизия), они добавляются в один и тот же список, связанный с этим индексом.
3. **Поиск**: При поиске значения по ключу, ключ хешируется, чтобы найти соответствующий индекс в массиве. Затем выполняется поиск по списку, связанному с этим индексом, чтобы найти нужную пару ключ-значение.

**Преимущества:**

- Простота реализации.
- Хорошая производительность в среднем случае.

**Недостатки:**

- В худшем случае, когда все ключи имеют одинаковый хеш, производительность может снизиться до O(n) для операций поиска, вставки и удаления.

### Открытая адресация (Open Addressing)

Открытая адресация — это альтернативный метод разрешения коллизий, при котором все элементы хранятся непосредственно в массиве хеш-таблицы. Если происходит коллизия, алгоритм ищет следующую доступную ячейку в массиве.

**Как это работает:**

1. **Хеширование**: Ключ хешируется для получения индекса в массиве.
2. **Поиск доступной ячейки**: Если ячейка с полученным индексом уже занята, алгоритм ищет следующую доступную ячейку. Это может быть сделано с помощью различных стратегий, таких как линейное зондирование, квадратичное зондирование или двойное хеширование.
3. **Вставка**: Пара ключ-значение вставляется в первую найденную доступную ячейку.

**Преимущества:**

- Более эффективное использование памяти, так как не требуется хранить дополнительные структуры данных, такие как списки.
- Хорошая производительность в случае хорошего распределения хешей.

**Недостатки:**

- Более сложная реализация по сравнению с методом цепочек.
- Производительность может снижаться, если таблица становится слишком заполненной, так как требуется больше времени на поиск доступных ячеек.

Оба метода имеют свои преимущества и недостатки, и выбор между ними зависит от конкретных требований и условий использования. В Python используется метод цепочек для разрешения коллизий в словарях.

______________________________________
Метод цепочек — это способ разрешения коллизий в хеш-таблицах. Вот как он работает кратко:

Хеширование: Ключ преобразуется в хеш, который определяет индекс в массиве.
Связанные списки: Каждый элемент массива указывает на связанный список, который хранит пары ключ-значение.
Разрешение коллизий: Если два ключа имеют одинаковый хеш, они добавляются в один и тот же связанный список.
Поиск: При поиске значения по ключу, сначала вычисляется хеш ключа, чтобы найти индекс в массиве, а затем выполняется поиск по связанному списку для нахождения нужного значения.

Таким образом, метод цепочек позволяет эффективно управлять коллизиями, сохраняя все элементы с одинаковым хешем в одном списке.

</details>

<details>
<summary> Когда возникают коллизии и какие методы их обработок существуют? Что используется в python?</summary>


Коллизии в хеш-таблицах возникают, когда два разных входных значения имеют один и тот же хеш, то есть когда два разных ключа отображаются в один и тот же индекс в массиве. Это может привести к проблемам, так как данные могут быть перезаписаны или потеряны, если не обрабатывать такие ситуации должным образом.

Вот несколько распространенных методов обработки коллизий:

1. **Метод цепочек (Chaining):** Каждый элемент хеш-таблицы является указателем на список (или другую структуру данных), содержащий все элементы, хешируемые в данный индекс. При коллизии новый элемент просто добавляется в этот список.

2. **Открытая адресация (Open Addressing):** При возникновении коллизии, алгоритм ищет следующее доступное место в массиве. Существует несколько подходов к открытой адресации:
   - Линейное исследование: проверка следующего индекса до нахождения свободного места.
   - Квадратичное исследование: проверка следующего индекса с квадратичным шагом.
   - Двойное хеширование: использование второго хеш-функции для определения шага поиска.

В Python для обработки коллизий в хеш-таблицах используется метод цепочек. Встроенные типы данных, такие как словари (`dict`), используют хеш-таблицы для хранения данных, и Python автоматически обрабатывает коллизии с помощью метода цепочек. Это позволяет эффективно управлять данными и обеспечивает быстрый доступ к элементам.
</details>


<details>
<summary> Вопрос 4. Когда возникают коллизии и какие методы их обработок существуют? Что используется в python?</summary>


Коллизии в хеш-таблицах возникают, когда два разных входных значения имеют один и тот же хеш, то есть когда два разных ключа отображаются в один и тот же индекс в массиве. Это может привести к проблемам, так как данные могут быть перезаписаны или потеряны, если не обрабатывать такие ситуации должным образом.


Метод цепочек (Chaining) и Открытая адресация. В python используется Метод цепочек

Метод цепочек (Chaining) - каждый элемент массива хеш-таблицы содержит указатель на список (или другой тип данных), который хранит все пары ключ значений, хешей которые соответствуют данном индексу.

Плюс проста реализация и Хорошая производительность в среднем случае.

В худшем случае, когда все ключи имеют одинаковый хеш, производительность может снизиться до O(n) для операций поиска, вставки и удаления.

Когда вы добавляете пару ключ-значение в хеш-таблицу, ключ хешируется для получения индекса в массиве.
Если два ключа имеют одинаковый хеш (коллизия), они добавляются в один и тот же список, связанный с этим индексом.
При поиске значения по ключу, ключ хешируется, чтобы найти соответствующий индекс в массиве. Затем выполняется поиск по списку, связанному с этим индексом, чтобы найти нужную пару ключ-значение.

Открытая адресация — это альтернативный метод разрешения коллизий, при котором все элементы хранятся непосредственно в массиве хеш-таблицы. Если происходит коллизия, алгоритм ищет следующую доступную ячейку в массиве.

Ключ хешируется для получения индекса в массиве.
Если ячейка с полученным индексом уже занята, алгоритм ищет следующую доступную ячейку. Это может быть сделано с помощью различных стратегий, таких как линейное зондирование, квадратичное зондирование или двойное хеширование.

Пара ключ-значение вставляется в первую найденную доступную ячейку.

Преимущества: Более эффективное использование памяти, так как не требуется хранить дополнительные структуры данных, такие как списки. Хорошая производительность в случае хорошего распределения хешей.

Недостатки: Более сложная реализация по сравнению с методом цепочек. Производительность может снижаться, если таблица становится слишком заполненной, так как требуется больше времени на поиск доступных ячеек.

</details>

<details>
<summary>Какие объекты могут являться ключами в словарях? Желательно максимально подробно с разными примерами</summary>

Ключи в словарях Python должны быть **хешируемыми** (hashable). Это единственное жёсткое требование.  
Хешируемый объект — это объект, у которого:

1. Определён метод `__hash__()`, возвращающий целое число, и это число **не меняется** за всё время жизни объекта.
2. Определён метод `__eq__()` для сравнения на равенство.
3. Если `a == b`, то `hash(a) == hash(b)`.

Если объект изменяемый (его содержимое можно изменить после создания), он **не может быть хешируемым** и, значит, не может быть ключом. Примеры **нельзя** использовать как ключи: `list`, `dict`, `set`, `bytearray`, большинство пользовательских классов по умолчанию (если не сделаны ими хешируемыми).

---

### ✅ Что **можно** использовать как ключи

#### 1. **Неизменяемые встроенные типы**
```python
d = {
    42: "число",
    3.14: "пи",
    "hello": "строка",
    True: "булево",
    None: "None",
    (1, 2): "кортеж",
    frozenset({1, 2, 3}): "frozenset",
    b"bytes": "байты",
    (1, "a", (2, 3)): "вложенный кортеж"
}
```

#### 2. **Классы-перечисления (Enum)**
```python
from enum import Enum

class Color(Enum):
    RED = 1
    GREEN = 2

d = {Color.RED: "красный", Color.GREEN: "зелёный"}
```

#### 3. **Пользовательские классы** (если они неизменяемые или переопределены `__hash__` и `__eq__`)
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return isinstance(other, Point) and (self.x, self.y) == (other.x, other.y)

    def __hash__(self):
        return hash((self.x, self.y))

d = {Point(1, 2): "точка"}
```

#### 4. **Именованные кортежи (`namedtuple`)**
```python
from collections import namedtuple

Person = namedtuple("Person", ["name", "age"])
d = {Person("Alice", 30): "инженер"}
```

#### 5. **Датаклассы с `frozen=True`**
```python
from dataclasses import dataclass

@dataclass(frozen=True)
class Product:
    name: str
    price: float

d = {Product("Молоко", 1.99): "молочный отдел"}
```

#### 6. **Специальные типы из стандартной библиотеки**
```python
import datetime
import ipaddress

d = {
    datetime.date(2025, 7, 30): "сегодня",
    ipaddress.IPv4Address("192.168.1.1"): "роутер"
}
```

---

### ❌ Что **нельзя** использовать как ключи

```python
bad_keys = [
    [1, 2, 3],          # list — изменяемый
    {"a": 1},           # dict — изменяемый
    {1, 2, 3},          # set — изменяемый
    bytearray(b"abc"),  # bytearray — изменяемый
]
```

Попытка использовать их вызовет `TypeError: unhashable type: 'list'`.

---

### 🧪 Проверка хешируемости
```python
def is_hashable(obj):
    try:
        hash(obj)
        return True
    except TypeError:
        return False

print(is_hashable((1, 2)))     # True
print(is_hashable([1, 2]))     # False
```

---

### 🧵 Подводные камни

- **Кортежи** могут быть ключами, **если все их элементы хешируемы**:
  ```python
  {(1, [2, 3]): "ошибка"}  # TypeError: unhashable type: 'list'
  ```

- **Булевы значения** `True` и `False** эквивалентны `1` и `0` при сравнении:
  ```python
  d = {True: "истина", 1: "единица"}
  print(d)  # {True: "единица"} — 1 перезаписал True
  ```

- **None** и **Ellipsis** (`...`) тоже хешируемы:
  ```python
  d = {None: "ничто", ...: "многоточие"}
  ```

---

### 📌 Итого
**Правило:** ключом может быть **любой объект**, у которого:
- `hash(obj)` не выбрасывает `TypeError`
- `obj` неизменяем (или изменяем, но хеш всегда одинаковый и `__eq__` реализован корректно)

Если сомневаетесь — проверяйте `hash(obj)` или `is_hashable(obj)`.

</details>

<details>
<summary>Создайте декоратор timer_decorator для подсчета времени работы функции и дополнительно ответь на вопрос "как создать декоратор с параметрами?</summary>

# Создайте декоратор timer_decorator для подсчета времени работы функции и дополнительно ответь на вопрос "как создать декоратор с параметрами?"

````
import time

def timer_decorator(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        print(f'Время выполнения функции - {time.time() - start} сек')
        return result
    return wrapper


# Пример использования декоратора 
@timer_decorator 
def example_function(numbers): 
    _ = [number for number in range(1, numbers + 1) if number % 2 == 0] 
    return 'Готово' 

# Вызов функции для теста 
result = example_function(10_000_000) 
print(result) 
```

Декораторы в Python - это своего рода "обёртка" для функций, позволяющая добавлять им новую функциональность без изменения их исходного кода. Представьте, что вам нужно украсить торт: вы не будете менять сам рецепт торта, а просто добавите сверху украшения. Так же и декораторы - они "украшают" функцию дополнительными действиями.

Декоратор - это функция, которая оборачивает другую функцию для изменения ее функциональности без изменения самого кода

Общее правило - декоратор принимает функцию в качестве аргумента и возвращает функцию.

Как передать параметры в декоратор?

Для этого нам понадобится еще один уровень вложенности функций. Внешняя функция будет принимать параметры декоратора, а внутренняя - саму декорируемую функцию.

def repeat(num_times):
    def decorator_repeat(func):
        def wrapper(*args, **kwargs):
            for _ in range(num_times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator_repeat

@repeat(num_times=3)
def greet(name):
    print(f"Привет, {name}!")

greet("Алиса")


</details>